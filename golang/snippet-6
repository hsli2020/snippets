code examples from https://youtube.com/@MarioCarrion

go install golang.org/x/tools/cmd/present
------------------------------------------------------------
package main

import (
	"fmt"
	"net/url"
)

func main() {
	// https://pkg.go.dev/vuln/GO-2022-0988

	fmt.Println(url.JoinPath("https://go.dev", "../x"))  // https://go.dev/../x
	fmt.Println(url.JoinPath("https://go.dev/", "../x")) // https://go.dev/x
}
------------------------------------------------------------
package main

import (
	"flag"
	"fmt"
)

func main() {
	var password string

	flag.StringVar(&password, "password", "default", "password to use for connecting to the database")
	flag.Parse()

	fmt.Println("password:", password)
}
------------------------------------------------------------
package main

import (
	"flag"
	"fmt"
	"net"
)

func main() {
	var ip net.IP

	// Type "net.IPv4" implements the interface "encoding.TextMarshaler",
	// specifically the method "MarshalText"
	flag.TextVar(&ip, "ip", net.IPv4(192, 168, 0, 100), "`IP address` to parse")
	flag.Parse()

	fmt.Printf("Value: %v\n", ip)
}
------------------------------------------------------------
package main

import (
	"fmt"
	"sync/atomic"
)

func main() {
	// <1.19:
	var i int64
	atomic.AddInt64(&i, 10)
	fmt.Println(atomic.LoadInt64(&i))

	// >=1.19:
	// var i atomic.Int64
	// i.Add(10)
	// fmt.Println(i.Load())
}
------------------------------------------------------------
//go:debug tarinsecurepath=0

package main

import (
	"archive/tar"
	"fmt"
	"io"
	"log"
	"os"
)

func main() {
	f, err := os.Open("example.tar")

	if err != nil {
		log.Fatalf("open failed %v\n", err)
	}
	defer f.Close()

	reader := tar.NewReader(f)

	for {
		hdr, err := reader.Next()
		if err == io.EOF {
			break
		}

		if err != nil {
			log.Fatalf("reader.Next %v\n", err)
		}

		fmt.Printf("Contents of %s:\n", hdr.Name)
		if _, err := io.Copy(os.Stdout, reader); err != nil {
			log.Fatalf("io.Copy %v\n", err)
		}

		fmt.Println()
	}
}
------------------------------------------------------------
package main

import (
	"context"
	"fmt"
	"log"
	"sync/atomic"
	"time"

	"golang.org/x/sync/errgroup"
)

type Service func(ctx context.Context) (int64, error)

func main() {
	svcs := []Service{
		Service1,
		Service2,
		Service3,
	}

	var total int64

	start := time.Now()

	g, ctx := errgroup.WithContext(context.Background())

	for _, svc := range svcs {
		svc := svc
		g.Go(func() error {
			v, err := svc(ctx)
			if err != nil {
				return err
			}

			_ = atomic.AddInt64(&total, v)

			return nil
		})
	}

	if err := g.Wait(); err != nil {
		log.Fatalln("Group", err)
	}

	fmt.Println("Total", total, "Duration", time.Now().Sub(start))
}

func Service1(ctx context.Context) (int64, error) {
	time.Sleep(100 * time.Millisecond)
	return 1, nil
}

func Service2(ctx context.Context) (int64, error) {
	time.Sleep(100 * time.Millisecond)
	return 2, nil
}

func Service3(ctx context.Context) (int64, error) {
	time.Sleep(200 * time.Millisecond)
	return 3, nil
}
------------------------------------------------------------
package main

import (
	"fmt"
	"sync"
)

func main() {
	c := Choreographer{}

	wgSubs := sync.WaitGroup{}
	wg := sync.WaitGroup{}

	for i := 0; i < 3; i++ {
		wgSubs.Add(1)
		wg.Add(1)

		go func(val int64) {
			ch := c.Subscribe()

			wgSubs.Done()

			for msg := range ch {
				c.Add(val)
				fmt.Println(msg, val)
			}

			wg.Done()
		}(int64(i) + 1)
	}

	wgSubs.Wait()

	c.Publish("message")
	c.Close()

	wg.Wait()

	fmt.Println("Value", c.Value())
}

type Choreographer struct {
	totalMux sync.RWMutex
	total    int64

	chansMux sync.RWMutex
	chans    []chan string
}

// Subscribe returns a channel meant to used for receiving messages.
func (o *Choreographer) Subscribe() <-chan string {
	o.chansMux.Lock()
	defer o.chansMux.Unlock()

	ch := make(chan string, 1)

	o.chans = append(o.chans, ch)

	return ch
}

// Publish sends a message to the subscribed channels.
func (o *Choreographer) Publish(msg string) {
	o.chansMux.RLock()
	defer o.chansMux.RUnlock()

	for _, ch := range o.chans {
		ch <- msg
	}
}

// Close indicates all subscribers no more messages are going to be sent.
func (o *Choreographer) Close() {
	o.chansMux.Lock()
	defer o.chansMux.Unlock()

	for _, ch := range o.chans {
		close(ch)
	}

	o.chans = nil
}

//-

// Add updates the local value by adding the received one.
func (o *Choreographer) Add(value int64) {
	o.totalMux.Lock()
	defer o.totalMux.Unlock()

	o.total += value
}

// Value prints out the current value
func (o *Choreographer) Value() int64 {
	o.totalMux.RLock()
	defer o.totalMux.RUnlock()

	return o.total
}
------------------------------------------------------------
package main

import (
	"encoding/json"
	"fmt"
	"log"
	"net/http"

	"github.com/gorilla/mux"
)

// User represents the user for this application
type User struct {
	// The name for this user
	Name string `json:"name"`

	// The birth year for this user
	BirthYear int `json:"birth_year"`
}

func main() {
	router := mux.NewRouter()

	router.HandleFunc("/users", func(w http.ResponseWriter, r *http.Request) {
		users := []User{
			{"Mario", 1990},
			{"Wario", 1980},
		}

		res, _ := json.Marshal(&users)

		_, _ = w.Write(res)
	}).Methods(http.MethodGet)

	router.HandleFunc("/users", func(w http.ResponseWriter, r *http.Request) {
		// XXX: Imagine validation is implemented here

		var user User

		if err := json.NewDecoder(r.Body).Decode(&user); err != nil {
			_, _ = w.Write([]byte("decoding failed"))
			w.WriteHeader(http.StatusInternalServerError)
			return
		}

		_, _ = w.Write([]byte(fmt.Sprintf("created %+v", user)))
	}).Methods(http.MethodPost)

	s := &http.Server{
		Addr:    ":8080",
		Handler: router,
	}

	log.Fatal(s.ListenAndServe())
}
------------------------------------------------------------
package main

import (
	"bytes"
	"context"
	"database/sql"
	"encoding/csv"
	"errors"
	"fmt"
	"io"
	"os"
	"strings"

	"github.com/go-sql-driver/mysql"
)

func main() {
	c := mysql.Config{
		User:      "root",
		Passwd:    "password",
		Addr:      "localhost:3306",
		Net:       "tcp",
		DBName:    "dbname",
		ParseTime: true,
	}

	db, err := sql.Open("mysql", c.FormatDSN())
	if err != nil {
		fmt.Println("sql.Open", err)
		return
	}
	defer func() {
		_ = db.Close()
		fmt.Println("closed")
	}()

	// Example 1: using the csv file as-is

	mysql.RegisterLocalFile("data.csv")

	_, err = db.ExecContext(context.Background(),
		`LOAD DATA LOCAL INFILE 'data.csv' INTO TABLE users
		FIELDS TERMINATED BY ','
		ENCLOSED BY '"'
		(first_name, last_name)
		`,
	)
	if err != nil {
		fmt.Println("db.ExecContext", err)
		return
	}

	// Example 2: augmenting the csv file

	mysql.RegisterReaderHandler("data", func() io.Reader {
		file, err := os.Open("data.csv")
		if err != nil {
			fmt.Println("os.Open", err)
			return nil
		}
		defer func() {
			_ = file.Close()
		}()

		buffer := bytes.Buffer{}

		csvWriter := csv.NewWriter(&buffer)

		csvReader := csv.NewReader(file)
		for {
			record, err := csvReader.Read()
			if errors.Is(err, io.EOF) {
				break
			}

			if err != nil {
				fmt.Println("csvR.Read", err)
				return nil
			}

			record[0] = strings.ToUpper(record[0])

			csvWriter.Write(record)
		}

		csvWriter.Flush()

		return &buffer
	})

	_, err = db.ExecContext(context.Background(),
		`LOAD DATA LOCAL INFILE 'Reader::data' INTO TABLE users
		FIELDS TERMINATED BY ','
		ENCLOSED BY '"'
		(first_name, last_name)
		`,
	)
	if err != nil {
		fmt.Println("db.ExecContext", err)
		return
	}
}
------------------------------------------------------------
package main

import (
	"context"
	"database/sql"
	"fmt"
	"time"

	"github.com/go-sql-driver/mysql"
)

func main() {
	c := mysql.Config{
		User:      "root",
		Passwd:    "password",
		Addr:      "localhost:3306",
		Net:       "tcp",
		DBName:    "dbname",
		ParseTime: true,
	}

	fmt.Println(c.FormatDSN())

	db, err := sql.Open("mysql", c.FormatDSN())
	if err != nil {
		fmt.Println("sql.Open", err)
		return
	}
	defer func() {
		_ = db.Close()
		fmt.Println("closed")
	}()

	if err := db.PingContext(context.Background()); err != nil {
		fmt.Println("db.PingContext", err)
		return
	}

	row := db.QueryRowContext(context.Background(),
		"SELECT updated_at FROM users WHERE name = ? AND birth_year = ?",
		"mario", 1900)
	if err := row.Err(); err != nil {
		fmt.Println("db.QueryRowContext", err)
		return
	}

	var updatedAt time.Time

	if err := row.Scan(&updatedAt); err != nil {
		fmt.Println("row.Scan", err)
		return
	}

	fmt.Println("updated_at", updatedAt)
}
------------------------------------------------------------
package benchmark

import "strings"

func Concat(a, b string) string {
	// Ineffecient implementation using fmt
	// return fmt.Sprintf("%s%s", a, b)

	// Efficient implementation starts here
	builder := strings.Builder{}

	builder.WriteString(a)
	builder.WriteString(b)

	return builder.String()
}
------------------------------------------------------------
package benchmark

import (
	"bytes"
	"fmt"
	"strings"
	"testing"
)

func BenchmarkConcat(b *testing.B) {
	for n := 0; n < b.N; n++ {
		Concat("a", "b")
	}
}

func BenchmarkFmtSprintf(b *testing.B) {
	var str string
	for n := 0; n < b.N; n++ {
		str = fmt.Sprintf("%s%s", str, "a")
	}
}

func BenchmarkBytesBuffer(b *testing.B) {
	var buf bytes.Buffer

	for n := 0; n < b.N; n++ {
		buf.WriteString("a")
	}
}

func BenchmarkStringsBuilder(b *testing.B) {
	var builder strings.Builder

	for n := 0; n < b.N; n++ {
		builder.WriteString("a")
	}
}
------------------------------------------------------------
package main

import (
	"context"
	"database/sql"
	"fmt"
	"net/url"

	_ "github.com/jackc/pgx/v4/stdlib"
)

func main() {
	dsn := url.URL{
		Scheme: "postgres",
		Host:   "localhost:5432",
		User:   url.UserPassword("user", "password"),
		Path:   "dbname",
	}

	q := dsn.Query()
	q.Add("sslmode", "disable")

	dsn.RawQuery = q.Encode()

	db, err := sql.Open("pgx", dsn.String())
	if err != nil {
		fmt.Println("sql.Open", err)
		return
	}
	defer func() {
		_ = db.Close()
		fmt.Println("closed")
	}()

	if err := db.PingContext(context.Background()); err != nil {
		fmt.Println("db.PingContext", err)
		return
	}

	row := db.QueryRowContext(context.Background(), "SELECT birth_year FROM users WHERE name = 'mario'")
	if err := row.Err(); err != nil {
		fmt.Println("db.QueryRowContext", err)
		return
	}

	var birth_year int64

	if err := row.Scan(&birth_year); err != nil {
		fmt.Println("row.Scan", err)
		return
	}

	fmt.Println("birth_year", birth_year)

	//-

	rows, err := db.QueryContext(context.Background(), "SELECT name, birth_year FROM users")
	if err != nil {
		fmt.Println("row.Scan", err)
		return
	}
	defer func() {
		_ = rows.Close()
	}()

	if rows.Err() != nil {
		fmt.Println("row.Err()", err)
		return
	}

	for rows.Next() {
		var name string
		var birth_year int64

		if err := rows.Scan(&name, &birth_year); err != nil {
			fmt.Println("rows.Scan", err)
			return
		}

		fmt.Println("name", name, "birth_year", birth_year)
	}
}
------------------------------------------------------------
package main

import (
	"errors"
	"fmt"
	"log"
	"net/http"
	"time"
)

const (
	ServerDefaultReadTimeout  time.Duration = 100 * time.Millisecond
	ServerDefaultWriteTimeout time.Duration = 100 * time.Millisecond
	ServerDefaultAddress      string        = ":8080"
)

type Option func(*http.Server) error

func WithAddr(addr string) func(*http.Server) error {
	return func(s *http.Server) error {
		s.Addr = addr
		return nil
	}
}

func WithReadTimeout(t time.Duration) func(*http.Server) error {
	return func(s *http.Server) error {
		if t > time.Second {
			return errors.New("timeout value not allowed")
		}

		s.ReadTimeout = t
		return nil
	}
}

func WithWriteTimeout(t time.Duration) func(*http.Server) error {
	return func(s *http.Server) error {
		if t > time.Second {
			return errors.New("timeout value not allowed")
		}

		s.WriteTimeout = t

		return nil
	}
}

func NewServer(opts ...Option) (http.Server, error) {
	s := http.Server{
		Addr:         ServerDefaultAddress,
		ReadTimeout:  ServerDefaultReadTimeout,
		WriteTimeout: ServerDefaultWriteTimeout,
	}

	for _, opt := range opts {
		if err := opt(&s); err != nil {
			return http.Server{}, fmt.Errorf("option failed %w", err)
		}
	}

	return s, nil
}

func main() {
	mux := http.NewServeMux()
	mux.HandleFunc("/", func(w http.ResponseWriter, req *http.Request) {
		fmt.Fprintf(w, "Hello")
	})

	s, err := NewServer(
		WithAddr(":9191"),
		WithReadTimeout(100*time.Millisecond),
		WithWriteTimeout(100*time.Millisecond),
	)

	if err != nil {
		log.Fatalln("Couldn't initialize server", err)
	}

	s.Handler = mux

	if err := s.ListenAndServe(); err != nil {
		log.Fatalln("Couldn't listen and serve", err)
	}
}
------------------------------------------------------------
package main

import (
	"context"
	"database/sql"
	"fmt"
	"net/url"

	_ "github.com/jackc/pgx/v4/stdlib"
)

type User struct {
	Name      *string
	BirthYear *int64
}

func main() {
	db, err := newDB()
	if err != nil {
		fmt.Println("newDB", err)
		return
	}

	defer func() {
		_ = db.Close()
		fmt.Println("closed")
	}()

	newName := func(s string) *string {
		return &s
	}

	newBirthYear := func(b int64) *int64 {
		return &b
	}

	if err := insertUsers(db, []User{
		{
			Name:      newName("mario1"),
			BirthYear: newBirthYear(1900),
		},
		{
			Name:      nil,
			BirthYear: newBirthYear(1901),
		},
	}); err != nil {
		fmt.Println("insertUsers", err)
	}
}

func insertUsers(db *sql.DB, users []User) error {
	tx, err := db.BeginTx(context.Background(), nil)
	if err != nil {
		return fmt.Errorf("db.BeginTx %w", err)
	}
	defer func() {
		_ = tx.Rollback()
	}()

	for _, user := range users {
		_, err := tx.ExecContext(context.Background(), "INSERT INTO users(name, birth_year) VALUES($1, $2)", user.Name, user.BirthYear)
		if err != nil {
			return fmt.Errorf("tx.ExecContext %w", err)
		}
	}

	if err := tx.Commit(); err != nil {
		return fmt.Errorf("tx.Commit %w", err)
	}

	return nil
}

func newDB() (*sql.DB, error) {
	dsn := url.URL{
		Scheme: "postgres",
		Host:   "localhost:5432",
		User:   url.UserPassword("user", "password"),
		Path:   "dbname",
	}

	q := dsn.Query()
	q.Add("sslmode", "disable")

	dsn.RawQuery = q.Encode()

	db, err := sql.Open("pgx", dsn.String())
	if err != nil {
		return nil, fmt.Errorf("sql.Open %w", err)
	}

	return db, nil
}
------------------------------------------------------------
package main

import (
	"context"
	"fmt"
	"net/url"

	"github.com/jackc/pgx/v4"
)

type User struct {
	Name      *string
	BirthYear *int64
}

func main() {
	conn, err := newConn()
	if err != nil {
		fmt.Println("newDB", err)
		return
	}

	defer func() {
		_ = conn.Close(context.Background())
		fmt.Println("closed")
	}()

	newName := func(s string) *string {
		return &s
	}

	newBirthYear := func(b int64) *int64 {
		return &b
	}

	if err := insertUsers(conn, []User{
		{
			Name:      newName("pgx0"),
			BirthYear: newBirthYear(1900),
		},
		{
			Name:      newName("pgx1"),
			BirthYear: newBirthYear(1901),
		},
	}); err != nil {
		fmt.Println("insertUsers", err)
	}
}

func insertUsers(conn *pgx.Conn, users []User) error {
	if err := conn.BeginFunc(context.Background(), func(tx pgx.Tx) error {
		for _, user := range users {
			_, err := tx.Exec(context.Background(), "INSERT INTO users(name, birth_year) VALUES($1, $2)", user.Name, user.BirthYear)
			if err != nil {
				return fmt.Errorf("tx.ExecContext %w", err)
			}
		}

		return nil
	}); err != nil {
		return fmt.Errorf("conn.BeginFunc %w", err)
	}

	return nil
}

func newConn() (*pgx.Conn, error) {
	dsn := url.URL{
		Scheme: "postgres",
		Host:   "localhost:5432",
		User:   url.UserPassword("user", "password"),
		Path:   "dbname",
	}

	q := dsn.Query()
	q.Add("sslmode", "disable")

	dsn.RawQuery = q.Encode()

	conn, err := pgx.Connect(context.Background(), dsn.String())
	if err != nil {
		return nil, fmt.Errorf("pgx.Connect%w", err)
	}

	return conn, nil
}
------------------------------------------------------------
package main

import (
	"context"
	"encoding/csv"
	"errors"
	"fmt"
	"io"
	"net/url"
	"os"
	"path"
	"strconv"
	"time"

	"github.com/jackc/pgx/v4"
)

func main() {
	conn, err := newConn()
	if err != nil {
		fmt.Println("newDB", err)
		return
	}

	defer func() {
		_ = conn.Close(context.Background())
		fmt.Println("closed")
	}()

	now := time.Now()

	if err := insertsUsers(conn); err != nil {
		fmt.Println("failed", err)
		return
	}

	fmt.Println("total", time.Since(now))
}

type RowSrc struct {
	cr     *csv.Reader
	values []interface{}
	err    error
}

func (r *RowSrc) Next() bool {
	record, err := r.cr.Read()
	if errors.Is(err, io.EOF) {
		return false
	}

	if err != nil {
		r.err = err
		return false
	}

	fmt.Println(record)

	age, err := strconv.Atoi(record[2])
	if err != nil {
		r.err = fmt.Errorf("strconv %w", err)
		return false
	}

	r.values = make([]interface{}, 3)
	r.values[0] = record[0]
	r.values[1] = record[1]
	r.values[2] = age

	return true
}

func (r *RowSrc) Values() ([]interface{}, error) {
	return r.values, r.err
}

func (r *RowSrc) Err() error {
	return r.err
}

func insertsUsers(conn *pgx.Conn) error {
	f, err := os.Open(path.Join("..", "data.csv"))
	if err != nil {
		return fmt.Errorf("os.Open %w", err)
	}

	rowSrc := RowSrc{
		cr: csv.NewReader(f),
	}

	count, err := conn.CopyFrom(context.Background(),
		pgx.Identifier{"users"},
		[]string{
			"first_name",
			"last_name",
			"age",
		},
		&rowSrc)
	if err != nil {
		return fmt.Errorf("conn.CopyFrom %w", err)
	}

	fmt.Println("rows", count)

	return nil
}

func newConn() (*pgx.Conn, error) {
	dsn := url.URL{
		Scheme: "postgres",
		Host:   "localhost:5432",
		User:   url.UserPassword("user", "password"),
		Path:   "dbname",
	}

	q := dsn.Query()
	q.Add("sslmode", "disable")

	dsn.RawQuery = q.Encode()

	conn, err := pgx.Connect(context.Background(), dsn.String())
	if err != nil {
		return nil, fmt.Errorf("pgx.Connect%w", err)
	}

	return conn, nil
}
------------------------------------------------------------
package main

import (
	"context"
	"encoding/csv"
	"errors"
	"fmt"
	"io"
	"net/url"
	"os"
	"path"
	"strconv"
	"time"

	"github.com/jackc/pgx/v4"
)

func main() {
	conn, err := newConn()
	if err != nil {
		fmt.Println("newDB", err)
		return
	}

	defer func() {
		_ = conn.Close(context.Background())
		fmt.Println("closed")
	}()

	now := time.Now()

	if err := insertsUsers(conn); err != nil {
		fmt.Println("failed", err)
		return
	}

	fmt.Println("total", time.Since(now))
}

func insertsUsers(conn *pgx.Conn) error {
	f, err := os.Open(path.Join("..", "data.csv"))
	if err != nil {
		return fmt.Errorf("os.Open %w", err)
	}

	cr := csv.NewReader(f)

	if err := conn.BeginTxFunc(context.Background(), pgx.TxOptions{}, func(tx pgx.Tx) error {
		for {
			record, err := cr.Read()
			if errors.Is(err, io.EOF) {
				break
			}

			if err != nil {
				return fmt.Errorf("cr.Read %w", err)
			}

			age, err := strconv.Atoi(record[2])
			if err != nil {
				return fmt.Errorf("strconv %w", err)
			}

			_, err = conn.Exec(context.Background(),
				"INSERT INTO users(first_name, last_name, age) VALUES($1, $2, $3)",
				record[0],
				record[1],
				age)
			if err != nil {
				return fmt.Errorf("conn.Exec %w", err)
			}
		}

		return nil
	}); err != nil {
		return fmt.Errorf("conn.BeginTxFunc %w", err)
	}

	return nil
}

func newConn() (*pgx.Conn, error) {
	dsn := url.URL{
		Scheme: "postgres",
		Host:   "localhost:5432",
		User:   url.UserPassword("user", "password"),
		Path:   "dbname",
	}

	q := dsn.Query()
	q.Add("sslmode", "disable")

	dsn.RawQuery = q.Encode()

	conn, err := pgx.Connect(context.Background(), dsn.String())
	if err != nil {
		return nil, fmt.Errorf("pgx.Connect%w", err)
	}

	return conn, nil
}
------------------------------------------------------------
package main

import (
	"fmt"
	"os"
	"os/signal"
	"syscall"
	"time"
)

func main() {
	fmt.Println("Process ID", os.Getpid())

	listenForWork()

	<-waitToExit()

	fmt.Println("exiting")
}

func listenForWork() {
	const workersN int = 5

	sc := make(chan os.Signal, 1)
	signal.Notify(sc, syscall.SIGTERM)

	//-

	workersC := make(chan struct{}, workersN)

	// 1) Listen for messages to process
	go func() {
		for {
			<-sc

			workersC <- struct{}{} // 2) Send to processing channel
		}
	}()

	go func() {
		var workers int

		for range workersC { // 3) Wait for messages to process
			workerID := (workers % workersN) + 1
			workers++

			fmt.Printf("%d<-\n", workerID)

			go func() { // 4) Process messages
				doWork(workerID)
			}()
		}
	}()
}

func waitToExit() <-chan struct{} {
	runC := make(chan struct{}, 1)

	sc := make(chan os.Signal, 1)

	signal.Notify(sc, os.Interrupt)

	go func() {
		defer close(runC)

		<-sc
	}()

	return runC
}

func doWork(id int) {
	fmt.Printf("<-%d starting\n", id)

	time.Sleep(3 * time.Second)

	fmt.Printf("<-%d completed\n", id)
}
------------------------------------------------------------
package main

import (
	"fmt"
	"os"
	"os/signal"
	"sync"
	"syscall"
)

func main() {
	fmt.Println("Process ID", os.Getpid())

	s := NewScheduler(5, 10)

	s.ListenForWork()

	fmt.Println("ready")

	<-waitToExit()

	s.Exit()

	fmt.Println("exiting")
}

func waitToExit() <-chan struct{} {
	runC := make(chan struct{}, 1)

	sc := make(chan os.Signal, 1)

	signal.Notify(sc, os.Interrupt)

	go func() {
		defer close(runC)

		<-sc
	}()

	return runC
}

//-

type Scheduler struct {
	workers   int
	msgC      chan struct{}
	signalC   chan os.Signal
	waitGroup sync.WaitGroup
}

func NewScheduler(workers, buffer int) *Scheduler {
	return &Scheduler{
		workers: workers,
		msgC:    make(chan struct{}, buffer),
		signalC: make(chan os.Signal, 1),
	}
}

func (s *Scheduler) ListenForWork() {
	go func() { // 1) Listen for messages to process

		signal.Notify(s.signalC, syscall.SIGTERM)

		for {
			<-s.signalC

			s.msgC <- struct{}{} // 2) Send to processing channel
		}
	}()

	s.waitGroup.Add(s.workers)

	for i := 0; i < s.workers; i++ {
		i := i
		go func() {
			for {
				select {
				case _, open := <-s.msgC: // 3) Wait for messages to process
					if !open { // closed, exiting
						fmt.Printf("%d closing\n", i+1)
						s.waitGroup.Done()

						return
					}

					fmt.Printf("%d<- Processing\n", i)
				}
			}
		}()
	}
}

func (s *Scheduler) Exit() {
	close(s.msgC)
	s.waitGroup.Wait()
}
------------------------------------------------------------
package sum

func Add(a, b int) int {
	if a == b {
		return 0
	}

	return a + b
}
------------------------------------------------------------
package sum

import "testing"

func TestAdd(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name   string
		inputA int
		inputB int
		output int
	}{
		{
			"When both are same",
			1,
			1,
			0,
		},
		{
			"When values are different",
			1,
			2,
			3,
		},
	}

	for _, test := range tests {
		test := test

		t.Run(test.name, func(t *testing.T) {
			t.Parallel()

			got := Add(test.inputA, test.inputB)
			if got != test.output {
				t.Errorf("got %d, want %d", got, test.expecjted)
			}
		})
	}
}
------------------------------------------------------------
package sum

type Value struct {
	A int
	B int
}

func Add(a, b Value) Value {
	if a == b {
		return Value{}
	}

	return Value{
		A: a.A + b.A,
		B: b.B + b.B,
	}
}
------------------------------------------------------------
package sum

import (
	"testing"
)

func TestAdd(t *testing.T) {
	t.Parallel()

	type input struct {
		a Value
		b Value
	}

	tests := []struct {
		name   string
		input  input
		output Value
	}{
		{
			"Both are the same",
			input{
				Value{A: 1, B: 2},
				Value{A: 1, B: 2},
			},
			Value{},
		},
		{
			"Values are different",
			input{
				Value{A: 1, B: 2},
				Value{A: 2, B: 2},
			},
			Value{A: 3, B: 4},
		},
	}

	for _, tt := range tests {
		tt := tt

		t.Run(tt.name, func(t *testing.T) {
			got := Add(tt.input.a, tt.input.b)
			if got != tt.output {
				t.Fatalf("got %v, wanted %v", got, tt.output)
			}
		})
	}
}
------------------------------------------------------------
package main

import (
	"context"
	"encoding/json"
	"flag"
	"fmt"
	"log"
	"net/http"
	"time"
)

func main() {
	var zip, appID, units string

	flag.StringVar(&appID, "appID", "", "OpenWeather token / appID")
	flag.StringVar(&zip, "zip", "90210", "Zip code to use")
	flag.StringVar(&units, "units", "imperial", "Units use: imperial/metric/standard")

	flag.Parse()

	// XXX Validations for arguments omitted

	ctx, cancel := context.WithTimeout(context.Background(), 500*time.Millisecond)
	defer cancel()

	res, err := requestWeather(ctx, &http.Client{}, appID, zip, units)
	if err != nil {
		log.Fatalf("couldn't request weather: %s\n", err)
	}

	fmt.Printf("%+v\n", res)
}

type Weather struct {
	Description string `json:"description"`
}
type Main struct {
	Temperature float32 `json:"temp"`
	FeelsLike   float32 `json:"feels_like"`
}

type Result struct {
	Weather []Weather `json:"weather"`
	Main    Main      `json:"main"`
}

func requestWeather(ctx context.Context, client *http.Client, appID, zip, units string) (Result, error) {
	req, err := http.NewRequestWithContext(ctx,
		http.MethodGet,
		"https://api.openweathermap.org/data/2.5/weather",
		nil)
	if err != nil {
		return Result{}, err
	}

	url := req.URL.Query()
	url.Add("zip", zip)
	url.Add("appid", appID)
	url.Add("units", units)

	req.URL.RawQuery = url.Encode()

	res, err := client.Do(req)
	if err != nil {
		return Result{}, err
	}
	defer res.Body.Close()

	if res.StatusCode != http.StatusOK {
		var errJSON struct {
			Message string `json:"message"`
		}

		if err := json.NewDecoder(res.Body).Decode(&errJSON); err != nil {
			return Result{}, err
		}

		return Result{}, fmt.Errorf(errJSON.Message)
	}

	var result Result

	if err := json.NewDecoder(res.Body).Decode(&result); err != nil {
		return Result{}, err
	}

	return result, nil
}
------------------------------------------------------------
package main

import (
	"context"
	_ "embed"
	"fmt"
	"io"
	"log"
	"os"
	"os/signal"
	"time"
)

// CGO_ENABLED=0 GOOS=darwin go build -a -installsuffix cgo ./main.go

//go:embed LICENSE
var license string

func main() {
	//- Embedded Files

	fmt.Println(license)

	//- Deprecation of io/ioutil

	f, err := os.Open("LICENSE")
	if err != nil {
		log.Fatalln("Couldn't open file", err)
	}

	b, err := io.ReadAll(f)
	if err != nil {
		log.Fatal("reading all", err)
	}

	fmt.Printf("%s", b)

	//- os/signal.NotifyContext

	fmt.Println("waiting for signal")

	ctx, stop := signal.NotifyContext(context.Background(), os.Interrupt)
	defer stop()

	select {
	case <-time.After(time.Second):
		fmt.Println("exited after timer, missed signal")
	case <-ctx.Done():
		fmt.Println("signal received:", ctx.Err())
		stop()
	}

	fmt.Println("exiting")
}
------------------------------------------------------------
package main

import (
	"bytes"
	"encoding/gob"
	"os"
	"time"

	"github.com/bradfitz/gomemcache/memcache"
)

type Client struct {
	client *memcache.Client
}

func NewMemcached() (*Client, error) {
	// XXX Assuming environment variable contains only one server
	client := memcache.New(os.Getenv("MEMCACHED"))

	if err := client.Ping(); err != nil {
		return nil, err
	}

	client.Timeout = 100 * time.Millisecond
	client.MaxIdleConns = 100

	return &Client{
		client: client,
	}, nil
}

func (c *Client) GetName(nconst string) (Name, error) {
	item, err := c.client.Get(nconst)
	if err != nil {
		return Name{}, err
	}

	b := bytes.NewReader(item.Value)

	var res Name

	if err := gob.NewDecoder(b).Decode(&res); err != nil {
		return Name{}, err
	}

	return res, nil
}

func (c *Client) SetName(n Name) error {
	var b bytes.Buffer

	if err := gob.NewEncoder(&b).Encode(n); err != nil {
		return err
	}

	return c.client.Set(&memcache.Item{
		Key:        n.NConst,
		Value:      b.Bytes(),
		Expiration: int32(time.Now().Add(25 * time.Second).Unix()),
	})
}
------------------------------------------------------------
package main

import (
	"context"
	"os"

	"github.com/jackc/pgx/v4/pgxpool"
)

type PostgreSQL struct {
	pool *pgxpool.Pool
}

func NewPostgreSQL() (*PostgreSQL, error) {
	pool, err := pgxpool.Connect(context.Background(), os.Getenv("DATABASE_URL"))
	if err != nil {
		return nil, err
	}

	return &PostgreSQL{
		pool: pool,
	}, nil
}

func (p *PostgreSQL) Close() {
	p.pool.Close()
}

func (p *PostgreSQL) FindByNConst(nconst string) (Name, error) {
	query := `SELECT nconst, primary_name, birth_year, death_year FROM "names" WHERE nconst = $1`

	var res Name

	if err := p.pool.QueryRow(context.Background(), query, nconst).
		Scan(&res.NConst, &res.Name, &res.BirthYear, &res.DeathYear); err != nil {
		return Name{}, err
	}

	return res, nil
}
------------------------------------------------------------
package main

import (
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"time"

	"github.com/gorilla/mux"
)

type Name struct {
	NConst    string `json:"nconst"`
	Name      string `json:"name"`
	BirthYear string `json:"birthYear"`
	DeathYear string `json:"deathYear"`
}

type Error struct {
	Message string `json:"error"`
}

func main() {
	db, err := NewPostgreSQL()
	if err != nil {
		log.Fatalf("Could not initialize Database connection %s", err)
	}
	defer db.Close()

	mc, err := NewMemcached()
	if err != nil {
		log.Fatalf("Could not initialize Memcached client %s", err)
	}

	//-

	router := mux.NewRouter()

	renderJSON := func(w http.ResponseWriter, val interface{}, statusCode int) {
		w.WriteHeader(statusCode)
		_ = json.NewEncoder(w).Encode(val)
	}

	router.HandleFunc("/names/{id}", func(w http.ResponseWriter, r *http.Request) {
		id := mux.Vars(r)["id"]

		val, err := mc.GetName(id)
		if err == nil {
			renderJSON(w, &val, http.StatusOK)
			return
		}

		name, err := db.FindByNConst(id)
		if err != nil {
			renderJSON(w, &Error{Message: err.Error()}, http.StatusInternalServerError)
			return
		}

		_ = mc.SetName(name) // XXX

		renderJSON(w, &name, http.StatusOK)
	})

	fmt.Println("Starting server :8080")

	srv := &http.Server{
		Handler:      router,
		Addr:         ":8080",
		WriteTimeout: 15 * time.Second,
		ReadTimeout:  15 * time.Second,
	}

	log.Fatal(srv.ListenAndServe())
}
------------------------------------------------------------
package main

import (
	"context"
	"os"

	"github.com/jackc/pgx/v4/pgxpool"
)

type PostgreSQLpgx struct {
	pool *pgxpool.Pool
}

func NewPostgreSQLpgx() (*PostgreSQLpgx, error) {
	pool, err := pgxpool.Connect(context.Background(), os.Getenv("DATABASE_URL"))
	if err != nil {
		return nil, err
	}

	return &PostgreSQLpgx{
		pool: pool,
	}, nil
}

func (p *PostgreSQLpgx) Close() {
	p.pool.Close()
}

func (p *PostgreSQLpgx) FindByNConst(nconst string) (Name, error) {
	query := `SELECT nconst, primary_name, birth_year, death_year FROM "names" WHERE nconst = $1`

	var res Name

	if err := p.pool.QueryRow(context.Background(), query, nconst).
		Scan(&res.NConst, &res.Name, &res.BirthYear, &res.DeathYear); err != nil {
		return Name{}, err
	}

	return res, nil
}
------------------------------------------------------------
package main

import (
	"context"
	"database/sql"
	"os"

	_ "github.com/lib/pq" // pgx also supported
)

type PostgreSQLsql struct {
	pool *sql.DB
}

func NewPostgreSQLsql() (*PostgreSQLsql, error) {
	pool, err := sql.Open("postgres", os.Getenv("DATABASE_URL"))
	if err != nil {
		return nil, err
	}

	if err := pool.Ping(); err != nil {
		return nil, err
	}

	return &PostgreSQLsql{
		pool: pool,
	}, nil
}

func (p *PostgreSQLsql) Close() {
	p.pool.Close()
}

func (p *PostgreSQLsql) FindByNConst(nconst string) (Name, error) {
	query := `SELECT nconst, primary_name, birth_year, death_year FROM "names" WHERE nconst = $1`

	var res Name

	if err := p.pool.QueryRowContext(context.Background(), query, nconst).
		Scan(&res.NConst, &res.Name, &res.BirthYear, &res.DeathYear); err != nil {
		return Name{}, err
	}

	return res, nil
}
------------------------------------------------------------
package main

import (
	"context"
	"os"

	"github.com/jmoiron/sqlx"
	_ "github.com/lib/pq" // pgx also supported
)

type PostgreSQLsqlx struct {
	db *sqlx.DB
}

func NewPostgreSQLsqlx() (*PostgreSQLsqlx, error) {
	db, err := sqlx.ConnectContext(context.Background(), "postgres", os.Getenv("DATABASE_URL"))
	if err != nil {
		return nil, err
	}

	return &PostgreSQLsqlx{
		db: db,
	}, nil
}

func (p *PostgreSQLsqlx) Close() {
	p.db.Close()
}

func (p *PostgreSQLsqlx) FindByNConst(nconst string) (Name, error) {
	query := `SELECT nconst, primary_name, birth_year, death_year FROM "names" WHERE nconst = $1`

	var result struct {
		NConst    string `db:"nconst"`
		Name      string `db:"primary_name"`
		BirthYear string `db:"birth_year"`
		DeathYear string `db:"death_year"`
	}

	if err := p.db.QueryRowx(query, nconst).StructScan(&result); err != nil {
		return Name{}, err
	}

	return Name{
		NConst:    result.NConst,
		Name:      result.Name,
		BirthYear: result.BirthYear,
		DeathYear: result.DeathYear,
	}, nil
}
------------------------------------------------------------
package main

import (
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"time"

	"github.com/gorilla/mux"
)

type Name struct {
	NConst    string `json:"nconst"`
	Name      string `json:"name"`
	BirthYear string `json:"birthYear"`
	DeathYear string `json:"deathYear"`
}

type Error struct {
	Message string `json:"error"`
}

func main() {
	router := mux.NewRouter()

	renderJSON := func(w http.ResponseWriter, val interface{}, statusCode int) {
		w.WriteHeader(statusCode)
		_ = json.NewEncoder(w).Encode(val)
	}

	//-

	dbSQL, err := NewPostgreSQLsql()
	if err != nil {
		log.Fatalf("Could not initialize Database connection using sqlx %s", err)
	}
	defer dbSQL.Close()

	router.HandleFunc("/names/sql/{id}", func(w http.ResponseWriter, r *http.Request) {
		id := mux.Vars(r)["id"]

		name, err := dbSQL.FindByNConst(id)
		if err != nil {
			renderJSON(w, &Error{Message: err.Error()}, http.StatusInternalServerError)
			return
		}

		renderJSON(w, &name, http.StatusOK)
	})

	//-

	dbSQLX, err := NewPostgreSQLsqlx()
	if err != nil {
		log.Fatalf("Could not initialize Database connection using sqlx %s", err)
	}
	defer dbSQLX.Close()

	router.HandleFunc("/names/sqlx/{id}", func(w http.ResponseWriter, r *http.Request) {
		id := mux.Vars(r)["id"]

		name, err := dbSQLX.FindByNConst(id)
		if err != nil {
			renderJSON(w, &Error{Message: err.Error()}, http.StatusInternalServerError)
			return
		}

		renderJSON(w, &name, http.StatusOK)
	})

	//-

	pgxDB, err := NewPostgreSQLpgx()
	if err != nil {
		log.Fatalf("Could not initialize Database connection using pgx %s", err)
	}
	defer pgxDB.Close()

	router.HandleFunc("/names/pgx/{id}", func(w http.ResponseWriter, r *http.Request) {
		id := mux.Vars(r)["id"]

		name, err := pgxDB.FindByNConst(id)
		if err != nil {
			renderJSON(w, &Error{Message: err.Error()}, http.StatusInternalServerError)
			return
		}

		renderJSON(w, &name, http.StatusOK)
	})

	//-

	fmt.Println("Starting server :8080")

	srv := &http.Server{
		Handler:      router,
		Addr:         ":8080",
		WriteTimeout: 15 * time.Second,
		ReadTimeout:  15 * time.Second,
	}

	log.Fatal(srv.ListenAndServe())
}
------------------------------------------------------------
package main

import (
	"bytes"
	"context"
	"encoding/gob"
	"os"
	"time"

	"github.com/go-redis/redis/v8"
)

type Client struct {
	client *redis.Client
}

func NewRedis() (*Client, error) {
	client := redis.NewClient(&redis.Options{
		Addr:        os.Getenv("REDIS"),
		DB:          0,
		DialTimeout: 100 * time.Millisecond,
		ReadTimeout: 100 * time.Millisecond,
	})

	if _, err := client.Ping(context.Background()).Result(); err != nil {
		return nil, err
	}

	return &Client{
		client: client,
	}, nil
}

func (c *Client) GetName(ctx context.Context, nconst string) (Name, error) {
	cmd := c.client.Get(ctx, nconst)

	cmdb, err := cmd.Bytes()
	if err != nil {
		return Name{}, err
	}

	b := bytes.NewReader(cmdb)

	var res Name

	if err := gob.NewDecoder(b).Decode(&res); err != nil {
		return Name{}, err
	}

	return res, nil
}

func (c *Client) SetName(ctx context.Context, n Name) error {
	var b bytes.Buffer

	if err := gob.NewEncoder(&b).Encode(n); err != nil {
		return err
	}

	return c.client.Set(ctx, n.NConst, b.Bytes(), 25*time.Second).Err()
}
------------------------------------------------------------
package main

import (
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"time"

	"github.com/gorilla/mux"
)

type Name struct {
	NConst    string `json:"nconst"`
	Name      string `json:"name"`
	BirthYear string `json:"birthYear"`
	DeathYear string `json:"deathYear"`
}

type Error struct {
	Message string `json:"error"`
}

func main() {
	db, err := NewPostgreSQL()
	if err != nil {
		log.Fatalf("Could not initialize Database connection %s", err)
	}
	defer db.Close()

	redis, err := NewRedis()
	if err != nil {
		log.Fatalf("Could not initialize Redis client %s", err)
	}

	//-

	router := mux.NewRouter()

	renderJSON := func(w http.ResponseWriter, val interface{}, statusCode int) {
		w.WriteHeader(statusCode)
		_ = json.NewEncoder(w).Encode(val)
	}

	router.HandleFunc("/names/{id}", func(w http.ResponseWriter, r *http.Request) {
		id := mux.Vars(r)["id"]

		val, err := redis.GetName(r.Context(), id)
		if err == nil {
			renderJSON(w, &val, http.StatusOK)
			return
		}

		name, err := db.FindByNConst(id)
		if err != nil {
			renderJSON(w, &Error{Message: err.Error()}, http.StatusInternalServerError)
			return
		}

		_ = redis.SetName(r.Context(), name) // XXX

		renderJSON(w, &name, http.StatusOK)
	})

	fmt.Println("Starting server :8080")

	srv := &http.Server{
		Handler:      router,
		Addr:         ":8080",
		WriteTimeout: 15 * time.Second,
		ReadTimeout:  15 * time.Second,
	}

	log.Fatal(srv.ListenAndServe())
}
------------------------------------------------------------
package main

import (
	"context"
	"encoding/json"
	"flag"
	"fmt"
	"log"
	"net/http"
	"time"
)

func main() {
	var zip, appID, units string

	flag.StringVar(&appID, "appID", "", "OpenWeather token / appID")
	flag.StringVar(&zip, "zip", "90210", "Zip code to use")
	flag.StringVar(&units, "units", "imperial", "Units use: imperial/metric/standard")

	flag.Parse()

	// XXX Validations for arguments omitted

	ctx, cancel := context.WithTimeout(context.Background(), 500*time.Millisecond)
	defer cancel()

	res, err := requestWeather(ctx, &http.Client{}, appID, zip, units)
	if err != nil {
		log.Fatalf("couldn't request weather: %s\n", err)
	}

	fmt.Printf("%+v\n", res)
}

type Weather struct {
	Description string `json:"description"`
}
type Main struct {
	Temperature float32 `json:"temp"`
	FeelsLike   float32 `json:"feels_like"`
}

type Result struct {
	Weather []Weather `json:"weather"`
	Main    Main      `json:"main"`
}

func requestWeather(ctx context.Context, client *http.Client, appID, zip, units string) (Result, error) {
	req, err := http.NewRequestWithContext(ctx,
		http.MethodGet,
		"https://api.openweathermap.org/data/2.5/weather",
		nil)
	if err != nil {
		return Result{}, err
	}

	url := req.URL.Query()
	url.Add("zip", zip)
	url.Add("appid", appID)
	url.Add("units", units)

	req.URL.RawQuery = url.Encode()

	res, err := client.Do(req)
	if err != nil {
		return Result{}, err
	}
	defer res.Body.Close()

	if res.StatusCode != http.StatusOK {
		var errJSON struct {
			Message string `json:"message"`
		}

		if err := json.NewDecoder(res.Body).Decode(&errJSON); err != nil {
			return Result{}, err
		}

		return Result{}, fmt.Errorf(errJSON.Message)
	}

	var result Result

	if err := json.NewDecoder(res.Body).Decode(&result); err != nil {
		return Result{}, err
	}

	return result, nil
}
------------------------------------------------------------
package main

import (
	"context"
	"errors"
	"net/http"
	"net/url"
	"path"
	"testing"

	"github.com/dnaeon/go-vcr/cassette"
	"github.com/dnaeon/go-vcr/recorder"
	"github.com/google/go-cmp/cmp"
	gock "gopkg.in/h2non/gock.v1"
)

func Test_requestWeather(t *testing.T) {
	t.Parallel()

	t.Cleanup(func() {
		gock.EnableNetworking()
		gock.OffAll()
	})

	gock.DisableNetworking()

	type input struct {
		ctx   context.Context
		appID string
		zip   string
		units string
	}

	type output struct {
		res     Result
		withErr bool
	}

	tests := []struct {
		name   string
		setup  func(t *testing.T) (*http.Client, func() error)
		input  input
		output output
	}{
		{
			"200",
			func(t *testing.T) (*http.Client, func() error) {
				r, err := recorder.New(path.Join("fixtures", "weather_200"))
				if err != nil {
					t.Fatalf("failed creating recorder %s", err)
				}

				cleanURL := func(u *url.URL) *url.URL {
					q := u.Query()
					q.Del("appid")

					u.RawQuery = q.Encode()

					return u
				}

				r.AddFilter(func(i *cassette.Interaction) error {
					u, err := url.Parse(i.Request.URL)
					if err != nil {
						return err
					}

					i.URL = cleanURL(u).String()

					return nil
				})

				r.SetMatcher(func(r *http.Request, i cassette.Request) bool {
					r.URL = cleanURL(r.URL)

					return cassette.DefaultMatcher(r, i)
				})

				return &http.Client{Transport: r}, r.Stop
			},
			input{
				context.Background(),
				"98fec8cb3815fe82d71cadd8acfb4dfa",
				"90210",
				"metric",
			},
			output{
				res: Result{
					Weather: []Weather{
						{
							Description: "clear sky",
						},
					},
					Main: Main{
						Temperature: 12.199999809265137,
						FeelsLike:   9.960000038146973,
					},
				},
			},
		},
		{
			"401",
			func(t *testing.T) (*http.Client, func() error) {
				r, err := recorder.New(path.Join("fixtures", "weather_401"))
				if err != nil {
					t.Fatalf("failed creating recorder %s", err)
				}

				return &http.Client{Transport: r}, r.Stop
			},
			input{
				context.Background(),
				"appID-401",
				"90210",
				"metric",
			},
			output{
				withErr: true,
			},
		},
		{
			"500",
			func(_ *testing.T) (*http.Client, func() error) {
				gock.New("https://api.openweathermap.org").
					MatchParams(map[string]string{
						"zip":   "90210",
						"appid": "appID-500",
						"units": "metric",
					}).
					Get("/data/2.5/weather").
					Reply(http.StatusInternalServerError)

				client := &http.Client{Transport: &http.Transport{}}
				gock.InterceptClient(client)

				return client, func() error {
					if gock.IsDone() == false {
						return errors.New("gock has pending mocks")
					}

					return nil
				}
			},
			input{
				context.Background(),
				"appID-500",
				"90210",
				"metric",
			},
			output{
				withErr: true,
			},
		},
		{
			"Error: invalid JSON",
			func(_ *testing.T) (*http.Client, func() error) {
				gock.New("https://api.openweathermap.org").
					MatchParams(map[string]string{
						"zip":   "90210",
						"appid": "appID-error",
						"units": "metric",
					}).
					Get("/data/2.5/weather").
					Reply(http.StatusOK).
					BodyString(`{"broken":`)

				client := &http.Client{Transport: &http.Transport{}}
				gock.InterceptClient(client)

				return client, func() error {
					if gock.IsDone() == false {
						return errors.New("gock has pending mocks")
					}

					return nil
				}
			},
			input{
				context.Background(),
				"appID-error",
				"90210",
				"metric",
			},
			output{
				withErr: true,
			},
		},
		{
			"Error: http.Client.Do",
			func(_ *testing.T) (*http.Client, func() error) {
				gock.New("https://api.openweathermap.org").
					MatchParams(map[string]string{
						"zip":   "90210",
						"appid": "appID-err-req",
						"units": "metric",
					}).
					Get("/data/2.5/weather").
					Reply(http.StatusMovedPermanently).
					SetHeader("Location", "")

				client := &http.Client{Transport: &http.Transport{}}
				gock.InterceptClient(client)

				return client, func() error {
					if gock.IsDone() == false {
						return errors.New("gock has pending mocks")
					}

					return nil
				}
			},
			input{
				context.Background(),
				"appID-err-req",
				"90210",
				"metric",
			},
			output{
				withErr: true,
			},
		},
		{
			"Error: http.NewRequestWithContext",
			func(_ *testing.T) (*http.Client, func() error) {
				return nil, func() error { return nil }
			},
			input{
				ctx: nil,
			},
			output{
				withErr: true,
			},
		},
	}

	for _, tt := range tests {
		tt := tt

		t.Run(tt.name, func(t *testing.T) {
			client, teardown := tt.setup(t)
			defer func() {
				if err := teardown(); err != nil {
					t.Fatalf("teardown failed %s", err)
				}
			}()

			actualRes, actualErr := requestWeather(tt.input.ctx, client, tt.input.appID, tt.input.zip, tt.input.units)

			if (actualErr != nil) != tt.output.withErr {
				t.Fatalf("expected error %t, actual %s", tt.output.withErr, actualErr)
			}

			if !cmp.Equal(tt.output.res, actualRes) {
				t.Fatalf("expected output do not match\n%s", cmp.Diff(tt.output.res, actualRes))
			}
		})
	}
}
------------------------------------------------------------
package main

import (
	"context"
	"fmt"
	"time"
)

func main() {
	ch := make(chan struct{})

	run := func(ctx context.Context) {
		n := 1
		for {
			select {
			case <-ctx.Done(): // 2. "ctx" is cancelled, we close "ch"
				fmt.Println("exiting")
				close(ch)
				return // returning not to leak the goroutine
			default:
				time.Sleep(time.Millisecond * 300)
				fmt.Println(n)
				n++
			}
		}
	}

	ctx, cancel := context.WithCancel(context.Background())
	go func() {
		time.Sleep(time.Second * 2)
		fmt.Println("goodbye")
		cancel() // 1. cancels "ctx"
	}()

	go run(ctx)

	fmt.Println("waiting to cancel...")

	<-ch // 3. "ch" is closed, we exit

	fmt.Println("bye")
}
------------------------------------------------------------
package main

import (
	"context"
	"fmt"
	"time"
)

const shortDuration = 1 * time.Millisecond

func main() {
	// Pass a context with a timeout to tell a blocking function that it
	// should abandon its work after the timeout elapses.
	ctx, cancel := context.WithTimeout(context.Background(), shortDuration)
	defer cancel()

	select {
	case <-time.After(1 * time.Second):
		fmt.Println("overslept")
	case <-ctx.Done():
		fmt.Println(ctx.Err()) // prints "context deadline exceeded"
	}
}
------------------------------------------------------------
package main

import (
	"context"
	"fmt"
	"log"
)

type jwt string

const auth jwt = "JWT"

func main() {
	ctx := context.WithValue(context.Background(), auth, "Bearer hi")

	//-

	bearer := ctx.Value(auth)
	str, ok := bearer.(string)
	if !ok {
		log.Fatalln("not a string")
	}

	fmt.Println("value:", str)
}
------------------------------------------------------------
package main

import "fmt"

type Interface interface {
	Method()
}

type String struct {
	Value string
}

func (s *String) Method() {
	fmt.Printf("s= %v\n", s)
}

func main() {
	var str *String
	fmt.Printf("str= %v\n", str) // <nil>
	str.Method()                 // <nil>

	(*String).Method(str) // Syntatic sugar

	var iface Interface = str
	iface.Method() // <nil>
}
------------------------------------------------------------
package main

import (
	"fmt"
)

type Interface interface {
	Method()
}

type String struct {
	Value string
}

func (s *String) Method() {}

type Integer int

func (i Integer) Method() {}

func main() {
	var iface Interface

	iface = &String{"hello world"}
	fmt.Printf("Value: %v, Type: %T\n", iface, iface)

	iface = Integer(100)
	fmt.Printf("Value: %v, Type: %T\n", iface, iface)
}
------------------------------------------------------------
package main

import "fmt"

type Interface interface {
	Method()
}

type Integer int

func (i Integer) Method() {}

func main() {
	var iface interface{} = Integer(100)

	t, ok := iface.(Integer)
	fmt.Printf("OK? %t, Value %v, Type %T\n", ok, t, t)

	iface = "hello"

	t, ok = iface.(Integer)
	fmt.Printf("OK? %t, Value %v, Type %T\n", ok, t, t)

	//-

	describe("hello")
	describe(Integer(100))
	describe(10)
}

func describe(i interface{}) {
	switch v := i.(type) {
	case Integer:
		fmt.Printf("int %d\n", v)
	case string:
		fmt.Printf("string %s\n", v)
	default:
		fmt.Printf("unknown %T - %v\n", v, v)
	}
}
------------------------------------------------------------
package main

import (
	"fmt"
	"time"
)

func main() {
	ch := make(chan int, 2)
	exit := make(chan struct{})

	go func() {
		for i := 0; i < 5; i++ {
			fmt.Println(time.Now(), i, "sending")
			ch <- i
			fmt.Println(time.Now(), i, "sent")

			time.Sleep(1 * time.Second)
		}

		fmt.Println(time.Now(), "all completed, leaving")

		close(ch)
	}()

	go func() {
		// XXX: This is overcomplicated because is only channel only, "select"
		// shines when using multiple channels.
		for {
			select {
			case v, open := <-ch:
				if !open {
					close(exit)
					return
				}

				fmt.Println(time.Now(), "received", v)
			}
		}

		// XXX: In cases where only one channel is used
		// for v := range ch {
		// 	fmt.Println(time.Now(), "received", v)
		// }

		// close(exit)
	}()

	fmt.Println(time.Now(), "waiting for everything to complete")

	<-exit

	fmt.Println(time.Now(), "exiting")
}
------------------------------------------------------------
package main

import (
	"encoding/csv"
	"fmt"
	"io"
	"os"
	"sync"
)

// What is the Fan-In concurrency pattern?
// Consolidation of multiple channels into one channel by multiplexing each recieved value.
func main() {
	ch1, err := readCSV("file1.csv")
	if err != nil {
		panic(fmt.Errorf("Could not read file1 %v\n", err))
	}

	ch2, err := readCSV("file2.csv")
	if err != nil {
		panic(fmt.Errorf("Could not read file2 %v\n", err))
	}

	//-

	exit := make(chan struct{})

	// chM := merge1(ch1, ch2)
	chM := merge2(ch1, ch2)

	go func() {
		for v := range chM {
			fmt.Println(v)
		}

		close(exit)
	}()

	<-exit

	fmt.Println("All completed, exiting")
}

func merge1(cs ...<-chan []string) <-chan []string {
	var wg sync.WaitGroup

	out := make(chan []string)

	send := func(c <-chan []string) {
		for n := range c {
			out <- n
		}

		wg.Done()
	}

	wg.Add(len(cs))

	for _, c := range cs {
		go send(c)
	}

	go func() {
		wg.Wait()

		close(out)
	}()

	return out
}

func merge2(cs ...<-chan []string) <-chan []string {
	chans := len(cs)
	wait := make(chan struct{}, chans)

	out := make(chan []string)

	send := func(c <-chan []string) {
		defer func() { wait <- struct{}{} }()

		for n := range c {
			out <- n
		}
	}

	for _, c := range cs {
		go send(c)
	}

	go func() {
		for range wait {
			chans--
			if chans == 0 {
				break
			}
		}

		close(out)
	}()

	return out
}

func readCSV(file string) (<-chan []string, error) {
	f, err := os.Open(file)
	if err != nil {
		return nil, fmt.Errorf("opening file %v\n", err)
	}

	ch := make(chan []string)

	cr := csv.NewReader(f)

	go func() {
		for {
			record, err := cr.Read()
			if err == io.EOF {
				close(ch)

				return
			}

			ch <- record
		}
	}()

	return ch, nil
}
------------------------------------------------------------
package main

import (
	"encoding/csv"
	"fmt"
	"io"
	"os"
)

// What is the Fan-Out concurrency pattern?
// Breakup of one channel into multiple ones by distributing each value.
func main() {
	ch1, err := readCSV("file1.csv")
	if err != nil {
		panic(fmt.Errorf("Could not read file1 %v\n", err))
	}

	//-

	br1 := breakup("1", ch1)
	br2 := breakup("2", ch1)
	br3 := breakup("3", ch1)

	for {
		if br1 == nil && br2 == nil && br3 == nil {
			break
		}

		select {
		case _, ok := <-br1:
			if !ok {
				br1 = nil
			}
		case _, ok := <-br2:
			if !ok {
				br2 = nil
			}
		case _, ok := <-br3:
			if !ok {
				br3 = nil
			}
		}
	}

	fmt.Println("All completed, exiting")
}

func breakup(worker string, ch <-chan []string) chan struct{} {
	chE := make(chan struct{})

	go func() {
		for v := range ch {
			fmt.Println(worker, v)
		}

		close(chE)
	}()

	return chE
}

func merge(cs ...<-chan []string) <-chan []string {
	chans := len(cs)
	wait := make(chan struct{}, chans)

	out := make(chan []string)

	send := func(c <-chan []string) {
		defer func() { wait <- struct{}{} }()

		for n := range c {
			out <- n
		}
	}

	for _, c := range cs {
		go send(c)
	}

	go func() {
		for range wait {
			fmt.Println(chans)
			chans--
			if chans == 0 {
				break
			}
		}

		close(out)
	}()

	return out
}

func readCSV(file string) (<-chan []string, error) {
	f, err := os.Open(file)
	if err != nil {
		return nil, fmt.Errorf("opening file %v\n", err)
	}

	ch := make(chan []string)

	cr := csv.NewReader(f)

	go func() {
		for {
			record, err := cr.Read()
			if err == io.EOF {
				close(ch)

				return
			}

			ch <- record
		}
	}()

	return ch, nil
}
------------------------------------------------------------
package main

import (
	"fmt"
	"os"
	"os/signal"
)

func main() {
	c := make(chan os.Signal)
	signal.Notify(c, os.Interrupt)

	fmt.Println("waiting")

	<-c

	fmt.Println("received")
}
------------------------------------------------------------
package main

import "fmt"

type CustomError int

func (_ CustomError) Error() string {
	return "error message"
}

func (_ CustomError) Is(err error) bool {
	return false
}

func (_ CustomError) As(target interface{}) bool {
	return false
}

func (_ CustomError) Unwrap() error {
	return nil
}

func main() {
	var err error

	err = CustomError(10)

	fmt.Printf("Error value: %v", err)
}
------------------------------------------------------------
package main

import (
	"fmt"
	"net/url"
)

func main() {
	u, err := url.Parse("https://url.xyz/?arg1=one;arg2=two&arg3=three")

	fmt.Println("err", err)
	fmt.Printf("%+v\n", u.Query())

	// Use https://pkg.go.dev/net/http#AllowQuerySemicolons to support previous behavior
}
------------------------------------------------------------
package main

import (
	"encoding/csv"
	"errors"
	"fmt"
	"io"
	"os"
	"sync"

	"golang.org/x/sync/errgroup"
)

/**
Concurrency Pattern using errgroup package

What is in errgroup?
Includes ways to do Synchronization, Error propagation and Context cancelation.

Works for groups of goroutines working on a common task.
*/
func main() {
	wait := waitGroups()
	// wait := errGroup()

	<-wait
}

func waitGroups() <-chan struct{} {
	ch := make(chan struct{}, 1)

	var wg sync.WaitGroup

	for _, file := range []string{"file1.csv", "file2.csv", "file3.csv"} {
		file := file

		wg.Add(1)

		go func() {
			defer wg.Done()

			ch, err := read(file)
			if err != nil {
				fmt.Printf("error reading %v\n", err)
			}

			for line := range ch {
				fmt.Println(line)
			}
		}()
	}

	go func() {
		wg.Wait()

		close(ch)
	}()

	return ch
}

func errGroup() <-chan struct{} {
	ch := make(chan struct{}, 1)

	var g errgroup.Group

	for _, file := range []string{"file1.csv", "file2.csv", "file3.csv"} {
		file := file

		g.Go(func() error {
			ch, err := read(file)
			if err != nil {
				return fmt.Errorf("error reading %w", err)
			}

			for line := range ch {
				fmt.Println(line)
			}

			return nil
		})
	}

	go func() {
		if err := g.Wait(); err != nil {
			fmt.Printf("Error reading files %v", err)
		}

		close(ch)
	}()

	return ch
}

func read(file string) (<-chan []string, error) {
	f, err := os.Open(file)
	if err != nil {
		return nil, fmt.Errorf("opening file %w", err)
	}

	ch := make(chan []string)

	go func() {
		cr := csv.NewReader(f)

		for {
			record, err := cr.Read()
			if errors.Is(err, io.EOF) {
				close(ch)

				return
			}

			ch <- record
		}
	}()

	return ch, nil
}
------------------------------------------------------------
package main

import (
	"encoding/csv"
	"errors"
	"fmt"
	"io"
	"os"

	"golang.org/x/sync/errgroup"
)

func main() {
	wait := errGroupWithErrChannel() // Using a function that returns an error channel
	// wait := errGroupWithType() // Using a type that saves Error as state

	<-wait
}

func errGroupWithErrChannel() <-chan struct{} {
	waitC := make(chan struct{}, 1)

	var g errgroup.Group

	for _, file := range []string{"file1.csv", "file2.csv", "file3.csv"} {
		file := file

		g.Go(func() error {
			readC, errC, err := readWithErrChannel(file)
			if err != nil {
				return fmt.Errorf("error reading %w", err)
			}

			loop := true

			for loop {
				select {
				case line, ok := <-readC:
					if ok {
						fmt.Println(line)
					} else {
						loop = false
					}
				case err = <-errC:
					loop = false
				}
			}

			return err
		})
	}

	go func() {
		if err := g.Wait(); err != nil {
			fmt.Printf("Error reading: files %v\n", err)
		}

		close(waitC)
	}()

	return waitC
}

func readWithErrChannel(file string) (<-chan []string, <-chan error, error) {
	f, err := os.Open(file)
	if err != nil {
		return nil, nil, fmt.Errorf("opening file %w", err)
	}

	ch := make(chan []string)
	errC := make(chan error, 1)

	go func() {
		defer func() {
			close(errC)
			close(ch)
		}()

		cr := csv.NewReader(f)

		for {
			record, err := cr.Read()
			if errors.Is(err, io.EOF) {
				return
			}

			if err != nil {
				errC <- err
				return
			}

			ch <- record
		}
	}()

	return ch, errC, nil
}

//-

type Reader struct {
	cr    *csv.Reader
	Error error
}

func newReader(file string) (*Reader, error) {
	f, err := os.Open(file)
	if err != nil {
		return nil, fmt.Errorf("opening file %w", err)
	}

	return &Reader{
		cr: csv.NewReader(f),
	}, nil
}

func (r *Reader) Read() <-chan []string {
	ch := make(chan []string)

	go func() {
		defer close(ch)

		for {
			record, err := r.cr.Read()
			if errors.Is(err, io.EOF) {
				return
			}

			if err != nil {
				r.Error = err
				return
			}

			ch <- record
		}
	}()

	return ch
}

func errGroupWithType() <-chan struct{} {
	waitC := make(chan struct{}, 1)

	var g errgroup.Group

	for _, file := range []string{"file1.csv", "file2.csv", "file3.csv"} {
		file := file

		g.Go(func() error {
			reader, err := newReader(file)
			if err != nil {
				return fmt.Errorf("error reading %w", err)
			}

			for line := range reader.Read() {
				fmt.Println(line)
			}

			return reader.Error
		})
	}

	go func() {
		if err := g.Wait(); err != nil {
			fmt.Printf("Error reading: files %v\n", err)
		}

		close(waitC)
	}()

	return waitC
}
------------------------------------------------------------
package main

import (
	"context"
	"encoding/csv"
	"errors"
	"fmt"
	"io"
	"os"
	"time"

	"golang.org/x/sync/errgroup"
)

func main() {
	ctx := context.Background()

	// ctx, cancel := context.WithTimeout(context.Background(), 1*time.Millisecond)
	// defer cancel()

	wait := errGroup(ctx)

	<-wait
}

func errGroup(ctx context.Context) <-chan struct{} {
	ch := make(chan struct{}, 1)

	g, ctx := errgroup.WithContext(ctx)

	for _, file := range []string{"file1.csv", "file2.csv", "file3.csv"} {
		file := file

		g.Go(func() error {
			ch, err := read(file)
			if err != nil {
				return fmt.Errorf("error reading %w", err)
			}

			for {
				select {
				case <-ctx.Done():
					fmt.Printf("Context completed %v\n", ctx.Err())

					return ctx.Err()
				case line, ok := <-ch:
					if !ok {
						return nil
					}

					fmt.Println(line)
				}
			}
		})
	}

	go func() {
		if err := g.Wait(); err != nil {
			fmt.Printf("Error reading files: %v", err)
		}

		close(ch)
	}()

	return ch
}

func read(file string) (<-chan []string, error) {
	f, err := os.Open(file)
	if err != nil {
		return nil, fmt.Errorf("opening file %w", err)
	}

	ch := make(chan []string)

	go func() {
		cr := csv.NewReader(f)

		time.Sleep(time.Millisecond) // XXX: Intentional sleep 

		for {
			record, err := cr.Read()
			if errors.Is(err, io.EOF) {
				close(ch)

				return
			}

			ch <- record
		}
	}()

	return ch, nil
}
------------------------------------------------------------
package main

import (
	"encoding/csv"
	"errors"
	"fmt"
	"io"
	"log"
	"os"
	"strings"
)

/**
Pipeline concurrency pattern
What is a Pipeline?
	...chain of processing elements arranged so that the output
	of each element is the input of the next one... (from Wikipedia)
*/
func main() {
	recordsC, err := readCSV("file1.csv")
	if err != nil {
		log.Fatalf("Could not read csv %v", err)
	}

	for val := range sanitize(titleize(recordsC)) {
		fmt.Printf("%v\n", val)
	}
}

// Read values
func readCSV(file string) (<-chan []string, error) {
	f, err := os.Open(file)
	if err != nil {
		return nil, fmt.Errorf("opening file %w\n", err)
	}

	ch := make(chan []string)

	go func() {
		cr := csv.NewReader(f)
		cr.FieldsPerRecord = 3

		for {
			record, err := cr.Read()
			if errors.Is(err, io.EOF) {
				close(ch)

				return
			}

			ch <- record
		}
	}()

	return ch, nil
}

// Remove "invalid" records
func sanitize(strC <-chan []string) <-chan []string {
	ch := make(chan []string)

	go func() {
		for val := range strC {
			if len(val[0]) > 3 {
				fmt.Println("skipped ", val)
				continue
			}

			ch <- val
		}

		close(ch)
	}()

	return ch
}

// Modify received values
func titleize(strC <-chan []string) <-chan []string {
	ch := make(chan []string)

	go func() {
		for val := range strC {
			val[0] = strings.Title(val[0])
			val[1], val[2] = val[2], val[1]

			ch <- val
		}

		close(ch)
	}()

	return ch
}
------------------------------------------------------------
package main

import (
	"fmt"
	"io"
	"log"
	"net/http"
	"time"

	"github.com/julienschmidt/httprouter"
)

func main() {
	router := httprouter.New()
	router.POST("/hello", func(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {
		body, err := io.ReadAll(r.Body)
		if err != nil {
			fmt.Println("io.ReadAll", err)

			return
		}

		fmt.Println("written")

		fmt.Fprint(w, "Hello ", string(body))
	})

	s := &http.Server{
		Addr:        ":8080",
		Handler:     router,
		ReadTimeout: 500 * time.Millisecond,
	}

	log.Fatal(s.ListenAndServe())
}
------------------------------------------------------------
package main

import (
	"fmt"
	"io"
	"log"
	"net/http"
	"time"

	"github.com/julienschmidt/httprouter"
)

func main() {
	router := httprouter.New()
	router.POST("/hello", func(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {
		body, err := io.ReadAll(r.Body)
		if err != nil {
			fmt.Println("io.ReadAll", err)

			return
		}
		defer r.Body.Close()

		fmt.Println("written")

		fmt.Fprint(w, "Hello ", string(body))
	})

	slowHandler := func(w http.ResponseWriter, r *http.Request) {
		body, err := io.ReadAll(r.Body)
		if err != nil {
			fmt.Println("io.ReadAll", err)

			return
		}
		defer r.Body.Close()

		fmt.Println("Sleeping...")

		time.Sleep(3 * time.Second)

		fmt.Fprintf(w, "H.e.l.l.o %s", string(body))
	}

	router.Handler(http.MethodPost, "/slow",
		http.TimeoutHandler(http.HandlerFunc(slowHandler), 2*time.Second, "Request took too long"))

	s := &http.Server{
		Addr:        ":8080",
		Handler:     router,
		ReadTimeout: 100 * time.Millisecond,
	}

	log.Fatal(s.ListenAndServe())
}
------------------------------------------------------------
//2021/09/16/bad-actor/main.go
package main

import (
	"context"
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
	"time"
)

type slowReader struct {
	Value string
	index int
}

func (s *slowReader) Read(p []byte) (n int, err error) {
	if s.index == len(s.Value) {
		fmt.Println("")

		return 0, io.EOF
	}

	p[0] = byte(s.Value[s.index])

	fmt.Printf("%s", string(s.Value[s.index]))

	time.Sleep(500 * time.Millisecond)

	s.index++

	return 1, nil
}

func main() {
	reader := slowReader{Value: "Wario"}

	req, err := http.NewRequestWithContext(context.Background(),
		http.MethodPost,
		"http://localhost:8080/hello",
		&reader)
	if err != nil {
		log.Fatalln(err)
	}

	client := http.Client{}

	res, err := client.Do(req)
	if err != nil {
		log.Fatalln(err)
	}
	defer res.Body.Close()

	io.Copy(os.Stdout, res.Body)

	fmt.Println("\nexiting")
}
------------------------------------------------------------
package main

import (
	"context"
	"flag"
	"fmt"
	"log"
	"net/url"

	"github.com/jackc/pgx/v4"
	_ "github.com/jackc/pgx/v4/stdlib" // To initialize `pgx` DB driver
)

// Passing in an `id` like:
//
// "33ca99ce-f1d1-46c2-b26e-a0ff45011b18' OR ''='"
//
// The value "33ca..." is irrelevant because the `OR` is used instead.

func main() {
	var id string

	flag.StringVar(&id, "id", "", "User ID to delete")

	flag.Parse()

	if id == "" {
		fmt.Println("id is blank, exiting")
		return
	}

	conn, err := newConn()
	if err != nil {
		log.Fatalln("Couldn't connect to DB", err)
	}

	//-

	query := fmt.Sprintf("DELETE FROM users WHERE id = '%s'", id)

	if _, err := conn.Exec(context.Background(), query); err != nil {
		log.Fatalln("Couldn't delete", err)
	}
}

func newConn() (*pgx.Conn, error) {
	dsn := url.URL{
		Scheme: "postgres",
		User:   url.UserPassword("user", "password"),
		Host:   "localhost:5432",
		Path:   "dbname",
	}

	q := dsn.Query()
	q.Add("sslmode", "disable")

	dsn.RawQuery = q.Encode()

	conn, err := pgx.Connect(context.Background(), dsn.String())
	if err != nil {
		return nil, fmt.Errorf("sql.Open: %w", err)
	}

	if err := conn.Ping(context.Background()); err != nil {
		return nil, fmt.Errorf("db.Ping: %w", err)
	}

	return conn, nil
}
------------------------------------------------------------
package main

import (
	"context"
	"database/sql"
	"flag"
	"fmt"
	"log"
	"net/url"

	_ "github.com/jackc/pgx/v4/stdlib" // To initialize `pgx` DB driver
)

// Passing in an `id` like:
//
// "33ca99ce-f1d1-46c2-b26e-a0ff45011b18' OR ''='"
//
// The value "33ca..." is irrelevant because the `OR` is used instead.

func main() {
	var id string

	flag.StringVar(&id, "id", "", "User ID to delete")

	flag.Parse()

	if id == "" {
		fmt.Println("id is blank, exiting")
		return
	}

	db, err := newDB()
	if err != nil {
		log.Fatalln("Couldn't connect to DB", err)
	}

	//-

	query := fmt.Sprintf("DELETE FROM users WHERE id = '%s'", id)

	if _, err := db.Exec(query); err != nil {
		log.Fatalln("Couldn't delete", err)
	}
}

func newDB() (*sql.DB, error) {
	dsn := url.URL{
		Scheme: "postgres",
		User:   url.UserPassword("user", "password"),
		Host:   "localhost:5432",
		Path:   "dbname",
	}

	q := dsn.Query()
	q.Add("sslmode", "disable")

	dsn.RawQuery = q.Encode()

	db, err := sql.Open("pgx", dsn.String())
	if err != nil {
		return nil, fmt.Errorf("sql.Open: %w", err)
	}

	if err := db.PingContext(context.Background()); err != nil {
		return nil, fmt.Errorf("db.Ping: %w", err)
	}

	return db, nil
}
------------------------------------------------------------
package main

import (
	"context"
	"flag"
	"fmt"
	"log"
	"net/url"

	"github.com/jackc/pgx/v4"
	_ "github.com/jackc/pgx/v4/stdlib" // To initialize `pgx` DB driver
)

// Passing in an `id` like WILL NOT allow SQL Injection:
//
// "33ca99ce-f1d1-46c2-b26e-a0ff45011b18' OR ''='"

func main() {
	var id string

	flag.StringVar(&id, "id", "", "User ID to delete")

	flag.Parse()

	if id == "" {
		fmt.Println("id is blank, exiting")
		return
	}

	conn, err := newConn()
	if err != nil {
		log.Fatalln("Couldn't connect to DB", err)
	}

	//-

	query := "DELETE FROM users WHERE id = $1"

	if _, err := conn.Exec(context.Background(), query, id); err != nil {
		log.Fatalln("Couldn't delete", err)
	}
}

func newConn() (*pgx.Conn, error) {
	dsn := url.URL{
		Scheme: "postgres",
		User:   url.UserPassword("user", "password"),
		Host:   "localhost:5432",
		Path:   "dbname",
	}

	q := dsn.Query()
	q.Add("sslmode", "disable")

	dsn.RawQuery = q.Encode()

	conn, err := pgx.Connect(context.Background(), dsn.String())
	if err != nil {
		return nil, fmt.Errorf("sql.Open: %w", err)
	}

	if err := conn.Ping(context.Background()); err != nil {
		return nil, fmt.Errorf("db.Ping: %w", err)
	}

	return conn, nil
}
------------------------------------------------------------
package main

import (
	"context"
	"database/sql"
	"flag"
	"fmt"
	"log"
	"net/url"

	_ "github.com/jackc/pgx/v4/stdlib" // To initialize `pgx` DB driver
)

// Passing in an `id` like:
//
// Passing in an `id` like WILL NOT allow SQL Injection:
//
// "33ca99ce-f1d1-46c2-b26e-a0ff45011b18' OR ''='"

func main() {
	var id string

	flag.StringVar(&id, "id", "", "User ID to delete")

	flag.Parse()

	if id == "" {
		fmt.Println("id is blank, exiting")
		return
	}

	db, err := newDB()
	if err != nil {
		log.Fatalln("Couldn't connect to DB", err)
	}

	//-

	// XXX: The placeholder value depends the database driver, some of them use
	// `?` instead of sequential $n values
	query := "DELETE FROM users WHERE id = $1"

	if _, err := db.Exec(query, id); err != nil {
		log.Fatalln("Couldn't delete", err)
	}
}

func newDB() (*sql.DB, error) {
	dsn := url.URL{
		Scheme: "postgres",
		User:   url.UserPassword("user", "password"),
		Host:   "localhost:5432",
		Path:   "dbname",
	}

	q := dsn.Query()
	q.Add("sslmode", "disable")

	dsn.RawQuery = q.Encode()

	db, err := sql.Open("pgx", dsn.String())
	if err != nil {
		return nil, fmt.Errorf("sql.Open: %w", err)
	}

	if err := db.PingContext(context.Background()); err != nil {
		return nil, fmt.Errorf("db.Ping: %w", err)
	}

	return db, nil
}
------------------------------------------------------------
package main

import (
	"context"
	"flag"
	"fmt"
	"log"
	"net/url"

	sq "github.com/Masterminds/squirrel"
	"github.com/jackc/pgx/v4"
	_ "github.com/jackc/pgx/v4/stdlib" // To initialize `pgx` DB driver
)

func main() {
	isAdmin := flag.Bool("admin", false, "Delete all admins")
	birthYear := flag.Int("birthyear", 0, "Maximum Birth Year for deleting users")

	flag.Parse()

	conn, err := newConn()
	if err != nil {
		log.Fatalln("Couldn't connect to DB", err)
	}

	//-

	psql := sq.Delete("users").Where("is_admin = ?", *isAdmin)

	if *birthYear > 0 {
		psql = psql.Where("birth_year > ?", *birthYear)
	}

	sql, args, err := psql.PlaceholderFormat(sq.Dollar).ToSql()
	if err != nil {
		log.Fatalln("Couldn't create SQL statement", err)
	}

	fmt.Println("query", sql, "args", args)

	//-

	if _, err := conn.Prepare(context.Background(), "deleteWithCondition", sql); err != nil {
		log.Fatalln("Couldn't prepare", err)
	}

	if _, err := conn.Exec(context.Background(), "deleteWithCondition", args...); err != nil {
		log.Fatalln("Couldn't delete", err)
	}
}

func newConn() (*pgx.Conn, error) {
	dsn := url.URL{
		Scheme: "postgres",
		User:   url.UserPassword("user", "password"),
		Host:   "localhost:5432",
		Path:   "dbname",
	}

	q := dsn.Query()
	q.Add("sslmode", "disable")

	dsn.RawQuery = q.Encode()

	conn, err := pgx.Connect(context.Background(), dsn.String())
	if err != nil {
		return nil, fmt.Errorf("sql.Open: %w", err)
	}

	if err := conn.Ping(context.Background()); err != nil {
		return nil, fmt.Errorf("db.Ping: %w", err)
	}

	return conn, nil
}
------------------------------------------------------------
package main

import (
	"context"
	"database/sql"
	"flag"
	"fmt"
	"log"
	"net/url"

	sq "github.com/Masterminds/squirrel"
	_ "github.com/jackc/pgx/v4/stdlib" // To initialize `pgx` DB driver
)

func main() {
	isAdmin := flag.Bool("admin", false, "Delete all admins")
	birthYear := flag.Int("birthyear", 0, "Maximum Birth Year for deleting users")

	flag.Parse()

	db, err := newDB()
	if err != nil {
		log.Fatalln("Couldn't connect to DB", err)
	}

	//-

	psql := sq.Delete("users").Where("is_admin = ?", *isAdmin)

	if *birthYear > 0 {
		psql = psql.Where("birth_year > ?", *birthYear)
	}

	sql, args, err := psql.PlaceholderFormat(sq.Dollar).ToSql()
	if err != nil {
		log.Fatalln("Couldn't create SQL statement", err)
	}

	fmt.Println("query", sql, "args", args)

	//-

	stmt, err := db.PrepareContext(context.Background(), sql)
	if err != nil {
		log.Fatalln("Couldn't prepare", err)
	}

	if _, err := stmt.ExecContext(context.Background(), args...); err != nil {
		log.Fatalln("Couldn't delete", err)
	}
}

func newDB() (*sql.DB, error) {
	dsn := url.URL{
		Scheme: "postgres",
		User:   url.UserPassword("user", "password"),
		Host:   "localhost:5432",
		Path:   "dbname",
	}

	q := dsn.Query()
	q.Add("sslmode", "disable")

	dsn.RawQuery = q.Encode()

	db, err := sql.Open("pgx", dsn.String())
	if err != nil {
		return nil, fmt.Errorf("sql.Open: %w", err)
	}

	if err := db.PingContext(context.Background()); err != nil {
		return nil, fmt.Errorf("db.Ping: %w", err)
	}

	return db, nil
}
------------------------------------------------------------
package main

import (
	"encoding/json"
	"fmt"
	"log"
	"net/http"

	"github.com/gorilla/mux"
)

// User represents the user for this application
// swagger:model
type User struct {
	// The name for this user
	// required: true
	// min lenght: 5
	Name string `json:"name"`

	// The birth year for this user
	// min: 1900
	// max: 2022
	BirthYear int `json:"birth_year"`
}

func main() {
	router := mux.NewRouter()

	router.HandleFunc("/users", func(w http.ResponseWriter, r *http.Request) {
		// swagger:operation GET /users getUsers
		//
		// Insert documentation
		//
		// ---
		// produces:
		// - application/json
		// responses:
		//   '200':
		//     description: user response
		//     schema:
		//       type: array
		//       items:
		//         "$ref": "#/definitions/User"

		users := []User{
			{"Mario", 1990},
			{"Wario", 1980},
		}

		res, _ := json.Marshal(&users)

		_, _ = w.Write(res)
	}).Methods(http.MethodGet)

	router.HandleFunc("/users", func(w http.ResponseWriter, r *http.Request) {
		// XXX: Imagine validation is implemented here

		// swagger:operation POST /users postUser
		//
		// Include documentation
		//
		// ---
		// produces:
		// - application/json
		// parameters:
		//   - name: Body
		//     in: body
		//     schema:
		//       "$ref": "#/definitions/User"
		// responses:
		//   '200':
		//     description: user response

		var user User

		if err := json.NewDecoder(r.Body).Decode(&user); err != nil {
			_, _ = w.Write([]byte("decoding failed"))
			w.WriteHeader(http.StatusInternalServerError)
			return
		}

		_, _ = w.Write([]byte(fmt.Sprintf("created %+v", user)))
	}).Methods(http.MethodPost)

	s := &http.Server{
		Addr:    ":8080",
		Handler: router,
	}

	log.Fatal(s.ListenAndServe())
}
------------------------------------------------------------
package main

import (
	"fmt"

	"golang.org/x/exp/constraints"
)

func Sum[V constraints.Float | constraints.Integer](m ...V) V {
	var s V
	for _, v := range m {
		s += v
	}
	return s
}

func main() {
	fmt.Println(Sum([]int64{1, 2, 3, 4}...))
	fmt.Println(Sum(1, 2, 3))
	fmt.Println(Sum(uint32(1), uint32(3)))
	fmt.Println(Sum(1.2, 2.3, 3.5, 4.6))
}
------------------------------------------------------------
package skip

//go:generate stringer -type=Currency

type Currency int

const (
	USD Currency = iota
	MXN
	PHP
)

//go:generate stringer -type=Country

type Country int

const (
	USA Country = iota
	Mexico
	Phillipines
)
------------------------------------------------------------
package main

import (
	"errors"
	"fmt"
	"io"
)

var ErrOne = fmt.Errorf("one")
var ErrTwo = fmt.Errorf("two")

func main() {
	// Using errors.Join
	join := errors.Join(ErrOne, ErrTwo)
	fmt.Printf("%+v\n", join)

	if errors.Is(join, ErrOne) {
		fmt.Println("One!")
	}

	if errors.Is(join, ErrTwo) {
		fmt.Println("Two!")
	}

	// Using fmt.Errorf with multiple %w
	efmt := fmt.Errorf("%w, %w", errors.New("fmt"), io.EOF)

	fmt.Printf("%+v\n", efmt)

	if errors.Is(efmt, io.EOF) {
		fmt.Println("End of File")
	}
}
------------------------------------------------------------
package main

import (
	"archive/tar"
	"fmt"
	"io"
	"log"
	"os"
	"path"
)

func main() {
	f, err := os.Open(path.Join("..", "example.tar"))

	if err != nil {
		log.Fatalf("open failed %v\n", err)
	}
	defer f.Close()

	reader := tar.NewReader(f)

	for {
		hdr, err := reader.Next()
		if err == io.EOF {
			break
		}

		if err != nil {
			log.Fatalf("reader.Next %v\n", err)
		}

		fmt.Printf("Contents of %s:\n", hdr.Name)
		if _, err := io.Copy(os.Stdout, reader); err != nil {
			log.Fatalf("io.Copy %v\n", err)
		}

		fmt.Println()
	}
}
------------------------------------------------------------
package main

import (
	"archive/zip"
	"fmt"
	"io"
	"log"
	"os"
	"path"
)

func main() {
	f, err := os.Open(path.Join("..", "example.zip"))

	if err != nil {
		log.Fatalf("open failed %v\n", err)
	}
	defer f.Close()

	fi, err := f.Stat()
	if err != nil {
		log.Fatalf("f.Stat failed %v\n", err)
	}

	r, err := zip.NewReader(f, fi.Size())
	if err != nil {
		log.Fatalf("NewReader failed %v\n", err)
	}

	for _, f := range r.File {
		fmt.Printf("Contents of %s:\n", f.Name)
		rc, err := f.Open()
		if err != nil {
			log.Fatal(err)
		}

		if _, err := io.Copy(os.Stdout, rc); err != nil {
			log.Fatalf("io.Copy %v\n", err)
		}

		rc.Close()
		fmt.Println()
	}
}
------------------------------------------------------------
package main

import (
	"fmt"
	"log"
	"time"
)

func main() {
	newYork, err := time.LoadLocation("America/New_York")
	if err != nil {
		log.Fatalf("time.LoadLocation %v\n", err)
	}

	now := time.Date(2022, time.February, 3, 8, 0, 0, 0, newYork)

	future := now.Add(time.Hour * 2)
	past := now.Add(time.Hour * -2)

	fmt.Printf("now(future) %v (-1 = future)\n", now.Compare(future))
	fmt.Printf("now(past) %v (+1 = past)\n", now.Compare(past))
	fmt.Printf("now(now) %v (0 = same)\n", now.Compare(now))

	//-

	fmt.Println(now.Format(time.DateTime))
	fmt.Println(now.Format(time.DateOnly))
	fmt.Println(now.Format(time.TimeOnly))
}
// now(future) -1 (-1 = future)
// now(past) 1 (+1 = past)
// now(now) 0 (0 = same)
//
// 2022-02-03 08:00:00
// 2022-02-03
// 08:00:00
------------------------------------------------------------
package main

import (
	"context"
	"fmt"
	"time"
)

func main() {
	ch := make(chan struct{})
	ctx := context.Background()

	// context.WithoutCancel

	ctxTimeout, cancel := context.WithTimeout(ctx, time.Millisecond*10)
	defer cancel()

	ctxNoCancel := context.WithoutCancel(ctx)

	select {
	case <-ctxTimeout.Done():
		fmt.Println("ctxTimeout.Error:", ctxTimeout.Err())
		close(ch)
	}

	<-ch

	fmt.Println("context.WithoutCancel=Error:", ctxNoCancel.Err())

	// context.WithDeadlineCause (WithTimeoutCause works similarly)

	fmt.Println("")

	ch = make(chan struct{})
	ctx = context.Background()

	ctxDeadline, cancelDeadline := context.WithDeadlineCause(ctx, time.Now().Add(time.Millisecond*10), fmt.Errorf("deadline cause"))
	defer cancelDeadline()

	select {
	case <-ctxDeadline.Done():
		fmt.Println("ctxDeadline.Error:", ctxDeadline.Err())
		close(ch)
	}

	<-ch

	fmt.Println("context.WithDeadlineCause=Error:", ctxDeadline.Err())
	fmt.Println("context.WithDeadlineCause=Cause:", context.Cause(ctxDeadline))

	// context.AfterFunc

	fmt.Println("")

	ch = make(chan struct{})
	ctx = context.Background()

	ctxTimeout, cancelTimeout := context.WithTimeout(ctx, time.Millisecond*10)
	defer cancelTimeout()

	afterFunc := context.AfterFunc(ctxTimeout, func() {
		fmt.Println("AfterFunc called")
		close(ch)
	})

	select {
	case <-ctxTimeout.Done():
		fmt.Println("ctxTimeout.Error:", ctxTimeout.Err())
		afterFunc()
	}

	<-ch

	fmt.Println("context.WithTimeout=Error:", ctxDeadline.Err())
}
------------------------------------------------------------
package main

import (
	"fmt"
	"sync"
	"time"
)

func main() {
	// sync.OnceValue (sync.OnceValues works the same)

	onceString := sync.OnceValue[string](func() string {
		time.Sleep(time.Second)
		return "sync.OnceValue: computed once!"
	})

	fmt.Println(time.Now(), onceString())
	fmt.Println(time.Now(), onceString())
	fmt.Println(time.Now(), onceString())

	// sync.OnceFunc
	fmt.Println("")

	onceFunc := sync.OnceFunc(func() {
		time.Sleep(time.Second)
		fmt.Println("sync.OnceFunc: computed once!")
	})

	fmt.Println(time.Now())
	onceFunc()
	fmt.Println(time.Now())
	onceFunc()
	fmt.Println(time.Now())
	onceFunc()
}
------------------------------------------------------------
// ./2022/07/08/consumer/main.go
package main

import (
	"fmt"
	"log"

	"github.com/confluentinc/confluent-kafka-go/kafka"
)

func main() {
	config := kafka.ConfigMap{
		"bootstrap.servers":  "localhost",
		"group.id":           "files-client",
		"auto.offset.reset":  "earliest",
		"enable.auto.commit": true,
	}

	client, err := kafka.NewConsumer(&config)
	if err != nil {
		log.Fatalln("Kafka.NewConsumer", err)
	}

	if err := client.Subscribe("files", nil); err != nil {
		log.Fatalln("client.Subscribe", err)
	}

	// XXX:
	// Refer to https://youtu.be/jr7OULxYm0A for a full example
	// using a Kafka Consumer

	run := true
	for run {
		ev := client.Poll(150)

		switch msg := ev.(type) {
		case *kafka.Message:
			fmt.Println("Message", string(msg.Value))
			run = false
		case kafka.Error:
			fmt.Println("Error", msg)
			run = false
		}
	}

	if err := client.Close(); err != nil {
		log.Fatalln("Close", err)
	}
}
------------------------------------------------------------
// ./2022/07/08/producer/main.go

package main

import (
	"fmt"
	"log"

	"github.com/confluentinc/confluent-kafka-go/kafka"
)

func main() {
	config := kafka.ConfigMap{
		"bootstrap.servers": "localhost",
	}

	client, err := kafka.NewProducer(&config)
	if err != nil {
		log.Fatalln("Kafka.NewProducer", err)
	}

	var topic = "files"

	if err := client.Produce(&kafka.Message{
		TopicPartition: kafka.TopicPartition{
			Topic:     &topic,
			Partition: kafka.PartitionAny,
		},
		Value: newMessage(),
	}, nil); err != nil {
		log.Fatalln("producer.Producer", err)
	}

	fmt.Println("message sent, exiting")

	client.Close()
}

func newMessage() []byte {
	return []byte("https://youtu.be/jr7OULxYm0A")

	// file, err := os.Open("Golang_Microservices_Events_Streaming_using_Apache_Kafka.mp4")
	// if err != nil {
	// 	log.Fatalln("os.Open", err)
	// }
	// defer file.Close()

	// data, err := io.ReadAll(file)
	// if err != nil {
	// 	log.Fatalln("ioutil.ReadAll", err)
	// }

	// return data
}
------------------------------------------------------------
package main

import (
	"fmt"
	"sync"
)

type PubSub[T any] struct {
	subscribers []chan T
	mu          sync.RWMutex
	closed      bool
}

func NewPubSub[T any]() *PubSub[T] {
	return &PubSub[T]{
		mu: sync.RWMutex{},
	}
}

func (s *PubSub[T]) Subscribe() <-chan T {
	s.mu.Lock()
	defer s.mu.Unlock()

	if s.closed {
		return nil
	}

	r := make(chan T)

	s.subscribers = append(s.subscribers, r)

	return r
}

func (s *PubSub[T]) Publish(value T) {
	s.mu.RLock()
	defer s.mu.RUnlock()

	if s.closed {
		return
	}

	for _, ch := range s.subscribers {
		ch <- value
	}
}

func (s *PubSub[T]) Close() {
	s.mu.Lock()
	defer s.mu.Unlock()

	if s.closed {
		return
	}

	for _, ch := range s.subscribers {
		close(ch)
	}

	s.closed = true
}

func main() {
	ps := NewPubSub[string]()

	wg := sync.WaitGroup{}

	//-

	s1 := ps.Subscribe()

	wg.Add(1)

	go func() {
		defer wg.Done()

		for {
			select {
			case val, ok := <-s1:
				if !ok {
					fmt.Print("sub 1, exiting\n")
					return
				}

				fmt.Println("sub 1, value ", val)
			}
		}
	}()

	//-

	s2 := ps.Subscribe()

	wg.Add(1)

	go func() {
		defer wg.Done()

		for val := range s2 {
			fmt.Println("sub 2, value ", val)
		}

		fmt.Print("sub 2, exiting\n")
	}()

	//-

	ps.Publish("one")
	ps.Publish("two")
	ps.Publish("three")

	ps.Close()

	wg.Wait()

	fmt.Println("completed")
}
------------------------------------------------------------
package conn

import (
	"encoding/json"
	"fmt"
	"log"
	"net/url"
)

func NewConnString() string {
	// XXX: Do not hardcode configuration values
	dsn := url.URL{
		Scheme: "postgres",
		User:   url.UserPassword("user", "password"),
		Host:   "localhost",
		Path:   "dbname",
	}

	return dsn.String()
}

func Print(val any) {
	res, err := json.MarshalIndent(val, "", "  ")
	if err != nil {
		log.Fatalf(err.Error())
	}

	fmt.Printf("%s\n", res)
}
------------------------------------------------------------
CREATE TABLE users(
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    UNIQUE (name)
);

CREATE TABLE roles(
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    UNIQUE (name)
);

CREATE TABLE users_roles(
    user_id UUID,
    role_id UUID,
    PRIMARY KEY(user_id, role_id),
    CONSTRAINT fk_users_roles_user FOREIGN KEY(user_id) REFERENCES users(id),
    CONSTRAINT fk_users_roles_role FOREIGN KEY(role_id) REFERENCES roles(id)
);

CREATE TYPE permission AS ENUM ('create', 'read', 'update', 'delete');

CREATE TABLE permissions(
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    role_id UUID,
    type permission NOT NULL,
    CONSTRAINT fk_permissons_role FOREIGN KEY(role_id) REFERENCES roles(id),
    UNIQUE (role_id, type)
);
------------------------------------------------------------
// Package internal defines the domain types used for this program.
package internal

import (
	"github.com/google/uuid"
)

type User struct {
	ID    uuid.UUID
	Name  string
	Roles []Role
}

type Role struct {
	ID          uuid.UUID
	Name        string
	Permissions []Permission
}

type PermissionType string

type Permission struct {
	ID     uuid.UUID
	RoleID uuid.UUID
	Type   PermissionType
}
------------------------------------------------------------
// Package postgresql represents the repositories using the pgx third party library.
package postgresql

import (
	"context"
	"fmt"

	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgconn"
)

type DBTX interface {
	Exec(context.Context, string, ...any) (pgconn.CommandTag, error)
	Query(context.Context, string, ...any) (pgx.Rows, error)
	QueryRow(context.Context, string, ...any) pgx.Row
	Prepare(context.Context, string, string) (*pgconn.StatementDescription, error)
}

func transaction(ctx context.Context, conn *pgx.Conn, f func(tx pgx.Tx) error) error {
	tx, err := conn.Begin(ctx)
	if err != nil {
		return fmt.Errorf("Begin %w", err)
	}

	if err := f(tx); err != nil {
		_ = tx.Rollback(ctx)

		return fmt.Errorf("f %w", err)
	}

	if err := tx.Commit(ctx); err != nil {
		return fmt.Errorf("Commit %w", err)
	}

	return nil
}
------------------------------------------------------------
package postgresql

import (
	"context"
	"fmt"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5"

	"github.com/MarioCarrion/videos/2023/transaction-in-context/internal"
)

type Role struct {
	conn *pgx.Conn
}

func NewRole(conn *pgx.Conn) *Role {
	return &Role{
		conn: conn,
	}
}

func (r *Role) Insert(ctx context.Context, name string, permissions []internal.Permission) (internal.Role, error) {
	var (
		role internal.Role
		err  error
	)

	err = transaction(ctx, r.conn, func(tx pgx.Tx) error {
		rq := roleQueries{conn: tx}

		role, err := rq.Insert(ctx, name)
		if err != nil {
			return fmt.Errorf("Insert %w", err)
		}

		for i, p := range permissions {
			permission, err := rq.InsertPermission(ctx, role.ID, p.Type)
			if err != nil {
				return fmt.Errorf("insertPermissionTx %w", err)
			}

			permissions[i] = permission
		}

		role.Permissions = permissions

		return nil
	})
	if err != nil {
		return internal.Role{}, fmt.Errorf("transaction %w", err)
	}

	return role, nil
}

func (r *Role) InsertPermission(ctx context.Context, roleID uuid.UUID, ptype internal.PermissionType) (internal.Permission, error) {
	var (
		permission internal.Permission
		err        error
	)

	err = transaction(ctx, r.conn, func(tx pgx.Tx) error {
		rq := roleQueries{conn: tx}

		permission, err = rq.InsertPermission(ctx, roleID, ptype)
		if err != nil {
			return fmt.Errorf("insertPermission %w", err)
		}

		return nil
	})
	if err != nil {
		return internal.Permission{}, fmt.Errorf("transaction %w", err)
	}

	return permission, nil
}

type roleQueries struct {
	conn DBTX
}

func (r *roleQueries) Insert(ctx context.Context, name string) (internal.Role, error) {
	const sql = `INSERT INTO roles(name) VALUES ($1) RETURNING id`

	row := r.conn.QueryRow(ctx, sql, &name)

	var id uuid.UUID

	if err := row.Scan(&id); err != nil {
		return internal.Role{}, fmt.Errorf("Scan %w", err)
	}

	return internal.Role{
		ID:   id,
		Name: name,
	}, nil
}

func (r *roleQueries) InsertPermission(ctx context.Context, roleID uuid.UUID, ptype internal.PermissionType) (internal.Permission, error) {
	const sql = `INSERT INTO permissions(role_id, type) VALUES ($1, $2) RETURNING id`

	row := r.conn.QueryRow(ctx, sql, roleID, &ptype)

	var id uuid.UUID

	if err := row.Scan(&id); err != nil {
		return internal.Permission{}, fmt.Errorf("Insert %w", err)
	}

	return internal.Permission{
		ID:     id,
		RoleID: roleID,
		Type:   ptype,
	}, nil
}
------------------------------------------------------------
package postgresql

import (
	"context"
	"fmt"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5"

	"github.com/MarioCarrion/videos/2023/transaction-in-context/internal"
)

type User struct {
	conn *pgx.Conn
}

func NewUser(conn *pgx.Conn) *User {
	return &User{
		conn: conn,
	}
}

func (u *User) Insert(ctx context.Context, name string) (internal.User, error) {
	uq := userQueries{conn: u.conn}

	return uq.Insert(ctx, name)
}

type userQueries struct {
	conn DBTX
}

func (u *userQueries) Insert(ctx context.Context, name string) (internal.User, error) {
	const sql = `INSERT INTO users(name) VALUES ($1) RETURNING id`

	row := u.conn.QueryRow(ctx, sql, &name)

	var id uuid.UUID

	if err := row.Scan(&id); err != nil {
		return internal.User{}, fmt.Errorf("Insert %w", err)
	}

	return internal.User{
		ID:   id,
		Name: name,
	}, nil
}
------------------------------------------------------------
package main

import (
	"context"
	"flag"
	"fmt"
	"log"
	"os"
	"strings"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5"

	cmdinternal "github.com/MarioCarrion/videos/2023/transaction-in-context/cmd/internal"
	"github.com/MarioCarrion/videos/2023/transaction-in-context/internal/postgresql"
)

func main() {
	var (
		userID  string
		roleIDs []uuid.UUID
	)

	flag.StringVar(&userID, "id", "", "id of user to select")
	flag.Func("roles", "comma separated list of Role IDs", func(s string) error {
		for _, str := range strings.Split(s, ",") {
			id, err := uuid.Parse(str)
			if err != nil {
				return fmt.Errorf("UUID Parsing error %w", err)
			}

			roleIDs = append(roleIDs, id)
		}

		return nil
	})
	flag.Parse()

	if userID == "" {
		flag.PrintDefaults()
		os.Exit(0)
	}

	id, err := uuid.Parse(userID)
	if err != nil {
		log.Fatalln("UUID Parsing error:", err)
	}

	//-

	ctx := context.Background()

	conn, err := pgx.Connect(ctx, cmdinternal.NewConnString())
	if err != nil {
		log.Fatalln("Connection error:", err)
	}

	userRoleRepo := postgresql.NewUserRole(conn)

	if err := userRoleRepo.Insert(ctx, id, roleIDs...); err != nil {
		log.Fatalln("userRoleRepo.Insert", err)
	}

	fmt.Println("Roles inserted")
}
------------------------------------------------------------
package postgresql

import (
	"context"
	"fmt"

	"github.com/MarioCarrion/videos/2023/transaction-in-context/internal"
	"github.com/google/uuid"
	"github.com/jackc/pgx/v5"
)

type UserCloner struct {
	conn *pgx.Conn
}

func NewUserCloner(conn *pgx.Conn) *UserCloner {
	return &UserCloner{
		conn: conn,
	}
}

func (u *UserCloner) Clone(ctx context.Context, id uuid.UUID, name string) (internal.User, error) {
	var user internal.User

	transaction(ctx, u.conn, func(tx pgx.Tx) error {
		urq := userRoleQueries{conn: tx}

		userFound, err := urq.Select(ctx, id)
		if err != nil {
			return fmt.Errorf("urq.Select(1) %w", err)
		}

		uq := userQueries{conn: tx}

		userNew, err := uq.Insert(ctx, name)
		if err != nil {
			return fmt.Errorf("uq.Insert %w", err)
		}

		for _, role := range userFound.Roles {
			if err := urq.Insert(ctx, userNew.ID, role.ID); err != nil {
				return fmt.Errorf("urq.Insert %w", err)
			}
		}

		userFound, err = urq.Select(ctx, userNew.ID)
		if err != nil {
			return fmt.Errorf("urq.Select(2) %w", err)
		}

		user = userFound

		return nil
	})

	return user, nil
}
------------------------------------------------------------
package postgresql

import (
	"context"
	"fmt"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5"

	"github.com/MarioCarrion/videos/2023/transaction-in-context/internal"
)

type UserRole struct {
	conn *pgx.Conn
}

func NewUserRole(conn *pgx.Conn) *UserRole {
	return &UserRole{
		conn: conn,
	}
}

func (u *UserRole) Insert(ctx context.Context, id uuid.UUID, roleIDs ...uuid.UUID) error {
	err := transaction(ctx, u.conn, func(tx pgx.Tx) error {
		urq := userRoleQueries{conn: tx}

		for _, roleID := range roleIDs {
			if err := urq.Insert(ctx, id, roleID); err != nil {
				return fmt.Errorf("Exec %w", err)
			}
		}

		return nil
	})
	if err != nil {
		return fmt.Errorf("transaction %w", err)
	}

	return nil
}

func (u *UserRole) Select(ctx context.Context, id uuid.UUID) (internal.User, error) {
	urq := userRoleQueries{conn: u.conn}

	return urq.Select(ctx, id)
}

type userRoleQueries struct {
	conn DBTX
}

func (u *userRoleQueries) Insert(ctx context.Context, id uuid.UUID, roleID uuid.UUID) error {
	const sql = `INSERT INTO users_roles(user_id, role_id) VALUES ($1, $2)`

	_, err := u.conn.Exec(ctx, sql, &id, &roleID)
	if err != nil {
		return fmt.Errorf("Exec %w", err)
	}

	return nil
}

func (u *userRoleQueries) Select(ctx context.Context, id uuid.UUID) (internal.User, error) {
	const sql = `
SELECT
	U.id AS user_id,
	U.name AS user_name,
	R.id AS role_id,
	R.name AS role_name,
	P.id AS permission_name,
	P.type AS permission_type
FROM
	users U
	LEFT JOIN users_roles UR ON U.id = UR.user_id
	LEFT JOIN roles R ON R.id = UR.role_id
	LEFT JOIN permissions P ON R.id = P.role_id
WHERE
	U.id = $1
`

	rows, err := u.conn.Query(ctx, sql, id)
	if err != nil {
		return internal.User{}, fmt.Errorf("Select %w", err)
	}

	roles := make(map[uuid.UUID]internal.Role)

	var (
		userId         uuid.UUID
		userName       *string
		roleId         uuid.UUID
		roleName       *string
		permissionId   uuid.UUID
		permissionType string
	)

	_, err = pgx.ForEachRow(rows,
		[]any{&userId, &userName, &roleId, &roleName, &permissionId, &permissionType},
		func() error {
			role, ok := roles[roleId]
			if !ok {
				role = internal.Role{
					ID:   roleId,
					Name: *roleName,
				}
			}

			role.Permissions = append(role.Permissions,
				internal.Permission{
					ID:     permissionId,
					RoleID: role.ID,
					Type:   internal.PermissionType(permissionType),
				})

			roles[roleId] = role

			return nil
		})

	if userName == nil {
		return internal.User{}, fmt.Errorf("user not found")
	}

	user := internal.User{
		ID:   userId,
		Name: *userName,
	}

	for _, p := range roles {
		user.Roles = append(user.Roles, p)
	}

	return user, nil
}
------------------------------------------------------------
package main

import (
	"context"
	"flag"
	"log"
	"os"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5"

	cmdinternal "github.com/MarioCarrion/videos/2023/transaction-in-context/cmd/internal"
	"github.com/MarioCarrion/videos/2023/transaction-in-context/internal/postgresql"
)

func main() {
	var userID string

	flag.StringVar(&userID, "id", "", "id of user to select")
	flag.Parse()

	if userID == "" {
		flag.PrintDefaults()
		os.Exit(0)
	}

	id, err := uuid.Parse(userID)
	if err != nil {
		log.Fatalln("UUID Parsing error:", err)
	}

	//-

	ctx := context.Background()

	conn, err := pgx.Connect(ctx, cmdinternal.NewConnString())
	if err != nil {
		log.Fatalln("Connection error:", err)
	}

	userRoleRepo := postgresql.NewUserRole(conn)

	user, err := userRoleRepo.Select(ctx, id)
	if err != nil {
		log.Fatalln("userRoleRepo.Select", err)
	}

	cmdinternal.Print(&user)
}
------------------------------------------------------------
package main

import (
	"context"
	"flag"
	"log"
	"os"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5"

	cmdinternal "github.com/MarioCarrion/videos/2023/transaction-in-context/cmd/internal"
	"github.com/MarioCarrion/videos/2023/transaction-in-context/internal/postgresql"
)

func main() {
	var userID, name string

	flag.StringVar(&userID, "id", "", "id of user to clone")
	flag.StringVar(&name, "name", "", "name of the new user")
	flag.Parse()

	if userID == "" {
		flag.PrintDefaults()
		os.Exit(0)
	}

	id, err := uuid.Parse(userID)
	if err != nil {
		log.Fatalln("UUID Parsing error:", err)
	}

	//-

	ctx := context.Background()

	conn, err := pgx.Connect(ctx, cmdinternal.NewConnString())
	if err != nil {
		log.Fatalln("Connection error:", err)
	}

	userClonerRepo := postgresql.NewUserCloner(conn)

	user, err := userClonerRepo.Clone(ctx, id, name)
	if err != nil {
		log.Fatalln("userClonerRepo.Clone", err)
	}

	cmdinternal.Print(&user)
}
------------------------------------------------------------
package main

import (
	"context"
	"flag"
	"log"
	"os"

	"github.com/jackc/pgx/v5"

	cmdinternal "github.com/MarioCarrion/videos/2023/transaction-in-context/cmd/internal"
	"github.com/MarioCarrion/videos/2023/transaction-in-context/internal/postgresql"
)

func main() {
	var name string

	flag.StringVar(&name, "name", "", "name of the user to insert")
	flag.Parse()

	if name == "" {
		flag.PrintDefaults()
		os.Exit(0)
	}

	//-

	ctx := context.Background()

	conn, err := pgx.Connect(ctx, cmdinternal.NewConnString())
	if err != nil {
		log.Fatalln("Connection error:", err)
	}

	userRepo := postgresql.NewUser(conn)

	user, err := userRepo.Insert(ctx, name)
	if err != nil {
		log.Fatalln("Insert error:", err)
	}

	cmdinternal.Print(&user)
}
------------------------------------------------------------
package main

import (
	"context"
	"flag"
	"log"
	"os"

	"github.com/jackc/pgx/v5"

	cmdinternal "github.com/MarioCarrion/videos/2023/transaction-in-context/cmd/internal"
	"github.com/MarioCarrion/videos/2023/transaction-in-context/internal"
	"github.com/MarioCarrion/videos/2023/transaction-in-context/internal/postgresql"
)

func main() {
	var (
		name                             string
		createP, readP, deleteP, updateP bool
	)

	flag.StringVar(&name, "name", "", "name of the role to insert")
	flag.BoolVar(&createP, "c", false, "indicates whether 'create' permission is enabled or not")
	flag.BoolVar(&readP, "r", false, "indicates whether 'read' permission is enabled or not")
	flag.BoolVar(&deleteP, "d", false, "indicates whether 'delete' permission is enabled or not")
	flag.BoolVar(&updateP, "u", false, "indicates whether 'update' permission is enabled or not")

	flag.Parse()

	if name == "" {
		flag.PrintDefaults()
		os.Exit(0)
	}

	//-

	permissions := make([]internal.Permission, 0, 4)

	updatePermissions := func(enabled bool, ptype string) {
		if !enabled {
			return
		}

		permissions = append(permissions,
			internal.Permission{
				Type: internal.PermissionType(ptype),
			})
	}

	updatePermissions(createP, "create")
	updatePermissions(readP, "read")
	updatePermissions(updateP, "update")
	updatePermissions(deleteP, "delete")

	//-

	ctx := context.Background()

	conn, err := pgx.Connect(ctx, cmdinternal.NewConnString())
	if err != nil {
		log.Fatalln("Connection error", err)
	}

	roleRepo := postgresql.NewRole(conn)

	r, err := roleRepo.Insert(ctx, name, permissions)
	if err != nil {
		log.Fatalln("Inserting error:", err)
	}

	cmdinternal.Print(&r)
}
------------------------------------------------------------
